-- Auto-generated by tools/build_mint.lua
return function()
  local __modules = {}
  local __cache = {}
  local function __mkNode(name, parent)
    local t = { Name = name, Parent = parent, children = {} }
    return t
  end
  local __scriptIndex = {}
  local __n1 = __mkNode("Mint", nil)
  __n1.__moduleName = "init"
  __scriptIndex["init"] = __n1
  local __n2 = __mkNode("components", __n1)
  __n1["components"] = __n2
  local __n3 = __mkNode("Tabs", __n2)
  __n2["Tabs"] = __n3
  __n3.__moduleName = "components/Tabs"
  __scriptIndex["components/Tabs"] = __n3
  local __n4 = __mkNode("Modal", __n2)
  __n2["Modal"] = __n4
  __n4.__moduleName = "components/Modal"
  __scriptIndex["components/Modal"] = __n4
  local __n5 = __mkNode("ExecutionControls", __n2)
  __n2["ExecutionControls"] = __n5
  __n5.__moduleName = "components/ExecutionControls"
  __scriptIndex["components/ExecutionControls"] = __n5
  local __n6 = __mkNode("Toggle", __n2)
  __n2["Toggle"] = __n6
  __n6.__moduleName = "components/Toggle"
  __scriptIndex["components/Toggle"] = __n6
  local __n7 = __mkNode("StatusBar", __n2)
  __n2["StatusBar"] = __n7
  __n7.__moduleName = "components/StatusBar"
  __scriptIndex["components/StatusBar"] = __n7
  local __n8 = __mkNode("Label", __n2)
  __n2["Label"] = __n8
  __n8.__moduleName = "components/Label"
  __scriptIndex["components/Label"] = __n8
  local __n9 = __mkNode("Panel", __n2)
  __n2["Panel"] = __n9
  __n9.__moduleName = "components/Panel"
  __scriptIndex["components/Panel"] = __n9
  local __n10 = __mkNode("Toolbar", __n2)
  __n2["Toolbar"] = __n10
  __n10.__moduleName = "components/Toolbar"
  __scriptIndex["components/Toolbar"] = __n10
  local __n11 = __mkNode("Slider", __n2)
  __n2["Slider"] = __n11
  __n11.__moduleName = "components/Slider"
  __scriptIndex["components/Slider"] = __n11
  local __n12 = __mkNode("ProgressBar", __n2)
  __n2["ProgressBar"] = __n12
  __n12.__moduleName = "components/ProgressBar"
  __scriptIndex["components/ProgressBar"] = __n12
  local __n13 = __mkNode("VariableInspector", __n2)
  __n2["VariableInspector"] = __n13
  __n13.__moduleName = "components/VariableInspector"
  __scriptIndex["components/VariableInspector"] = __n13
  local __n14 = __mkNode("TextInput", __n2)
  __n2["TextInput"] = __n14
  __n14.__moduleName = "components/TextInput"
  __scriptIndex["components/TextInput"] = __n14
  local __n15 = __mkNode("Notification", __n2)
  __n2["Notification"] = __n15
  __n15.__moduleName = "components/Notification"
  __scriptIndex["components/Notification"] = __n15
  local __n16 = __mkNode("Console", __n2)
  __n2["Console"] = __n16
  __n16.__moduleName = "components/Console"
  __scriptIndex["components/Console"] = __n16
  local __n17 = __mkNode("Button", __n2)
  __n2["Button"] = __n17
  __n17.__moduleName = "components/Button"
  __scriptIndex["components/Button"] = __n17
  local __n18 = __mkNode("QueueManager", __n2)
  __n2["QueueManager"] = __n18
  __n18.__moduleName = "components/QueueManager"
  __scriptIndex["components/QueueManager"] = __n18
  local __n19 = __mkNode("CodeEditor", __n2)
  __n2["CodeEditor"] = __n19
  __n19.__moduleName = "components/CodeEditor"
  __scriptIndex["components/CodeEditor"] = __n19
  local __n20 = __mkNode("PerformanceMonitor", __n2)
  __n2["PerformanceMonitor"] = __n20
  __n20.__moduleName = "components/PerformanceMonitor"
  __scriptIndex["components/PerformanceMonitor"] = __n20
  local __n21 = __mkNode("FileBrowser", __n2)
  __n2["FileBrowser"] = __n21
  __n21.__moduleName = "components/FileBrowser"
  __scriptIndex["components/FileBrowser"] = __n21
  local __n22 = __mkNode("Dropdown", __n2)
  __n2["Dropdown"] = __n22
  __n22.__moduleName = "components/Dropdown"
  __scriptIndex["components/Dropdown"] = __n22
  local __n23 = __mkNode("core", __n1)
  __n1["core"] = __n23
  local __n24 = __mkNode("ComponentBase", __n23)
  __n23["ComponentBase"] = __n24
  __n24.__moduleName = "core/ComponentBase"
  __scriptIndex["core/ComponentBase"] = __n24
  local __n25 = __mkNode("Event", __n23)
  __n23["Event"] = __n25
  __n25.__moduleName = "core/Event"
  __scriptIndex["core/Event"] = __n25
  local __n26 = __mkNode("Validator", __n23)
  __n23["Validator"] = __n26
  __n26.__moduleName = "core/Validator"
  __scriptIndex["core/Validator"] = __n26
  local __n27 = __mkNode("Storage", __n23)
  __n23["Storage"] = __n27
  __n27.__moduleName = "core/Storage"
  __scriptIndex["core/Storage"] = __n27
  local __n28 = __mkNode("ThemeManager", __n23)
  __n23["ThemeManager"] = __n28
  __n28.__moduleName = "core/ThemeManager"
  __scriptIndex["core/ThemeManager"] = __n28
  local __n29 = __mkNode("ErrorHandler", __n23)
  __n23["ErrorHandler"] = __n29
  __n29.__moduleName = "core/ErrorHandler"
  __scriptIndex["core/ErrorHandler"] = __n29
  local __n30 = __mkNode("Queue", __n23)
  __n23["Queue"] = __n30
  __n30.__moduleName = "core/Queue"
  __scriptIndex["core/Queue"] = __n30
  local __n31 = __mkNode("Hotkeys", __n23)
  __n23["Hotkeys"] = __n31
  __n31.__moduleName = "core/Hotkeys"
  __scriptIndex["core/Hotkeys"] = __n31
  local __n32 = __mkNode("Responsive", __n23)
  __n23["Responsive"] = __n32
  __n32.__moduleName = "core/Responsive"
  __scriptIndex["core/Responsive"] = __n32
  local __n33 = __mkNode("Util", __n23)
  __n23["Util"] = __n33
  __n33.__moduleName = "core/Util"
  __scriptIndex["core/Util"] = __n33
  local __n34 = __mkNode("Animator", __n23)
  __n23["Animator"] = __n34
  __n34.__moduleName = "core/Animator"
  __scriptIndex["core/Animator"] = __n34
  local __n35 = __mkNode("LogManager", __n23)
  __n23["LogManager"] = __n35
  __n35.__moduleName = "core/LogManager"
  __scriptIndex["core/LogManager"] = __n35
  local __n36 = __mkNode("Registry", __n23)
  __n23["Registry"] = __n36
  __n36.__moduleName = "core/Registry"
  __scriptIndex["core/Registry"] = __n36
  local __root = __n1
  __modules["components/Toolbar"] = function(require, script)
    -- Toolbar component: horizontal button group for common actions
    -- Props:
    -- Items: array of { id=string, text=string, icon=string?, style='Primary'|'Secondary'|'Ghost', Action=string?, OnClick=function? }
    -- Spacing (number) default 6
    -- Parent (Instance)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Registry = require(script.Parent.Parent.core.Registry)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Toolbar = Base.extend({})
    
    function Toolbar.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Toolbar)
    	self.Items = props.Items or {}
    
    	local theme = Theme.current()
    	local root = Util.Create("Frame", {
    		Name = "MintToolbar",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		AutomaticSize = Enum.AutomaticSize.XY,
    		Size = UDim2.fromOffset(10, 36),
    	})
    	self:_own(root)
    	Util.Roundify(root, 8, theme.colors.border, 0.9)
    	Util.Padding(root, 6)
    	local layout = Util.HList(root, props.Spacing or 6, Enum.VerticalAlignment.Center)
    	layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    
    	local function addItem(it)
    		local btn = Util.Create("TextButton", {
    			AutoButtonColor = false,
    			BackgroundColor3 = (it.style == 'Ghost') and Color3.new(0,0,0) or (it.style == 'Secondary' and theme.colors.inputBg or theme.colors.primary),
    			BackgroundTransparency = (it.style == 'Ghost') and 1 or 0,
    			BorderSizePixel = 0,
    			Size = UDim2.fromOffset(88, 28),
    			Text = tostring(it.text or it.id or "Button"),
    			TextColor3 = (it.style == 'Primary') and Color3.new(1,1,1) or theme.colors.text,
    			Font = Enum.Font.GothamSemibold,
    			TextSize = 14,
    		})
    		Util.Roundify(btn, 6, theme.colors.border, 0.8)
    		btn.Parent = root
    		self:_trackConn(btn.MouseButton1Click:Connect(function()
    			if it.OnClick then pcall(it.OnClick) end
    			if it.Action then Registry.invoke(it.Action) end
    		end))
    		return btn
    	end
    
    	for _, it in ipairs(self.Items) do addItem(it) end
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		for _, child in ipairs(root:GetChildren()) do
    			if child:IsA("TextButton") then
    				local st = child:FindFirstChildOfClass("UIStroke"); if st then st.Color = newTheme.colors.border end
    			end
    		end
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return Toolbar
    
  end
  __modules["core/LogManager"] = function(require, script)
    -- LogManager: central log bus with levels, filtering, and events
    local Event = require(script.Parent.Event)
    
    local LogManager = {}
    
    LogManager.added = Event.new() -- fires (entry)
    LogManager.cleared = Event.new()
    
    LogManager._logs = {}
    LogManager._max = 1000
    
    -- entry: { t = os time, level = 'info'|'warn'|'error'|'debug'|'output', message = string }
    function LogManager.append(level, message)
    	local entry = {
    		t = os.time(),
    		level = string.lower(level or 'info'),
    		message = tostring(message or ''),
    	}
    	LogManager._logs[#LogManager._logs+1] = entry
    	if #LogManager._logs > LogManager._max then
    		table.remove(LogManager._logs, 1)
    	end
    	LogManager.added:Fire(entry)
    	return entry
    end
    
    function LogManager.clear()
    	LogManager._logs = {}
    	LogManager.cleared:Fire()
    end
    
    function LogManager.list(filter)
    	filter = filter or {}
    	local out = {}
    	for _, e in ipairs(LogManager._logs) do
    		local ok = true
    		if filter.level and e.level ~= filter.level then ok = false end
    		if filter.search and filter.search ~= '' then
    			if not string.find(string.lower(e.message), string.lower(filter.search), 1, true) then ok = false end
    		end
    		if ok then out[#out+1] = e end
    	end
    	return out
    end
    
    return LogManager
    
  end
  __modules["core/Validator"] = function(require, script)
    -- Validator: basic script validation helpers (lightweight static checks)
    -- API:
    -- Validator.basicSyntax(text) -> ok:boolean, errInfo? { line, col, msg }
    
    local Validator = {}
    
    -- Very lightweight checks: bracket balance and unclosed quotes
    function Validator.basicSyntax(text)
    	local stack = {}
    	local line = 1
    	local col = 0
    	local inString = false
    	local stringChar = nil -- '"' or '\''
    	local escape = false
    
    	local opens = { ['(']=')', ['{']='}', ['[']=']' }
    	local closes = { [')']=true, ['}']=true, [']']=true }
    
    	for i = 1, #text do
    		local ch = string.sub(text, i, i)
    		if ch == '\n' then
    			line += 1
    			col = 0
    		else
    			col += 1
    		end
    
    		if inString then
    			if escape then
    				escape = false
    			elseif ch == '\\' then
    				escape = true
    			elseif ch == stringChar then
    				inString = false
    				stringChar = nil
    			end
    		else
    			if ch == '"' or ch == '\'' then
    				inString = true
    				stringChar = ch
    			elseif opens[ch] then
    				table.insert(stack, { ch = ch, line = line, col = col })
    			elseif closes[ch] then
    				local top = stack[#stack]
    				if not top or opens[top.ch] ~= ch then
    					return false, { line = line, col = col, msg = "Unmatched closing bracket '"..ch.."'" }
    				end
    				stack[#stack] = nil
    			end
    		end
    	end
    
    	if inString then
    		return false, { line = line, col = col, msg = "Unterminated string literal" }
    	end
    	if #stack > 0 then
    		local top = stack[#stack]
    		return false, { line = top.line, col = top.col, msg = "Unclosed bracket '"..top.ch.."'" }
    	end
    	return true
    end
    
    return Validator
    
  end
  __modules["core/Storage"] = function(require, script)
    -- Storage: pluggable auto-save/load system for scripts and settings
    -- Default is in-memory. Consumers can provide backend via Storage.setBackend({ save = fn(key, tbl), load = fn(key) -> tbl })
    -- API: Storage.save(key, tbl), Storage.load(key) -> tbl|nil, Storage.enableAuto(key, getterFn, intervalSec)
    
    local HttpService = game:GetService("HttpService")
    
    local Storage = {}
    
    local _backend = {
    	save = function(key, tbl)
    		Storage._memory = Storage._memory or {}
    		Storage._memory[key] = HttpService:JSONEncode(tbl)
    		return true
    	end,
    	load = function(key)
    		if Storage._memory and Storage._memory[key] then
    			local ok, decoded = pcall(function()
    				return HttpService:JSONDecode(Storage._memory[key])
    			end)
    			if ok then return decoded end
    		end
    		return nil
    	end,
    }
    
    function Storage.setBackend(impl)
    	if type(impl) == "table" and type(impl.save) == "function" and type(impl.load) == "function" then
    		_backend = impl
    	else
    		error("Storage.setBackend expects { save=function, load=function }")
    	end
    end
    
    function Storage.save(key, tbl)
    	return _backend.save(tostring(key), tbl)
    end
    
    function Storage.load(key)
    	return _backend.load(tostring(key))
    end
    
    -- Auto-save helper: periodically calls getterFn() and saves under key
    function Storage.enableAuto(key, getterFn, interval)
    	interval = interval or 10
    	task.spawn(function()
    		while true do
    			task.wait(interval)
    			local ok, data = pcall(getterFn)
    			if ok and data ~= nil then
    				pcall(Storage.save, key, data)
    			end
    		end
    	end)
    end
    
    return Storage
    
  end
  __modules["core/Registry"] = function(require, script)
    -- Registry: maps string action names to callable functions
    local Event = require(script.Parent.Event)
    local ErrorHandler = require(script.Parent.ErrorHandler)
    
    local Registry = {
    	_map = {},
    	changed = Event.new(),
    }
    
    -- Register a function by name
    function Registry.register(name, fn, meta)
    	assert(type(name) == "string" and name ~= "", "Registry.register requires a non-empty string name")
    	assert(type(fn) == "function", "Registry.register requires a function")
    	Registry._map[name] = { fn = fn, meta = meta }
    	Registry.changed:Fire("register", name)
    	return true
    end
    
    -- Remove a function
    function Registry.unregister(name)
    	if Registry._map[name] then
    		Registry._map[name] = nil
    		Registry.changed:Fire("unregister", name)
    		return true
    	end
    	return false
    end
    
    function Registry.has(name)
    	return Registry._map[name] ~= nil
    end
    
    function Registry.list()
    	local items = {}
    	for k, v in pairs(Registry._map) do
    		items[#items+1] = { name = k, meta = v.meta }
    	end
    	table.sort(items, function(a,b) return a.name < b.name end)
    	return items
    end
    
    -- Invoke a function by name. Returns ok, resultOrErr
    function Registry.invoke(name, ...)
    	local entry = Registry._map[name]
    	if not entry then
    		local msg = string.format("No action '%s' registered", tostring(name))
    		ErrorHandler.notify("warning", msg)
    		return false, msg
    	end
    	local ok, result = pcall(entry.fn, ...)
    	if not ok then
    		local err = string.format("Action '%s' failed: %s", tostring(name), tostring(result))
    		ErrorHandler.notify("error", err)
    		return false, err
    	end
    	return true, result
    end
    
    return Registry
    
  end
  __modules["components/Toggle"] = function(require, script)
    -- Toggle (switch) component
    -- Props:
    -- Label (string)
    -- Value (boolean) default false
    -- OnChanged (function:boolean)
    -- Action (string) optional; invokes Registry.invoke(Action, value)
    -- Parent (Instance) optional
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Registry = require(script.Parent.Parent.core.Registry)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Toggle = Base.extend({})
    
    function Toggle.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Toggle)
    	self.Props = props
    	self._value = props.Value == true
    
    	local theme = Theme.current()
    
    	local root = Util.Create("Frame", {
    		Name = "MintToggle",
    		BackgroundTransparency = 1,
    		Size = UDim2.fromOffset(200, 28),
    	})
    	self:_own(root)
    
    	local layout = Util.HList(root, 8)
    	layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    
    	local knobW, knobH = 40, 22
    	local track = Util.Create("TextButton", {
    		Name = "Track",
    		Size = UDim2.fromOffset(knobW, knobH),
    		AutoButtonColor = false,
    		BackgroundColor3 = theme.colors.border,
    		BorderSizePixel = 0,
    		Text = "",
    	})
    	Util.Roundify(track, knobH/2, theme.colors.border, 0.4)
    	track.Parent = root
    
    	local dot = Util.Create("Frame", {
    		Name = "Dot",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = UDim2.fromOffset(knobH-6, knobH-6),
    		Position = UDim2.fromOffset(3,3),
    	})
    	Util.Roundify(dot, (knobH-6)/2)
    	dot.Parent = track
    
    	local text = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, -knobW-8, 1, 0),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		Text = tostring(props.Label or "Toggle"),
    		TextColor3 = theme.colors.text,
    		Font = Enum.Font.Gotham,
    		TextSize = 14,
    	})
    	text.Parent = root
    
    	local function apply(v, animate)
    		self._value = v
    		local goalTrack = { BackgroundColor3 = v and theme.colors.primary or theme.colors.border }
    		local goalDot = { Position = v and UDim2.fromOffset(knobW - (knobH-6) - 3, 3) or UDim2.fromOffset(3,3) }
    		if animate then
    			Animator.tween(track, Animator.Durations.Fast, goalTrack)
    			Animator.tween(dot, Animator.Durations.Fast, goalDot)
    		else
    			track.BackgroundColor3 = goalTrack.BackgroundColor3
    			dot.Position = goalDot.Position
    		end
    	end
    
    	apply(self._value, false)
    
    	self:_trackConn(track.MouseButton1Click:Connect(function()
    		apply(not self._value, true)
    		if props.OnChanged then
    			local ok, err = pcall(props.OnChanged, self._value)
    			if not ok then warn(err) end
    		end
    		if props.Action then
    			Registry.invoke(props.Action, self._value)
    		end
    	end))
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		text.TextColor3 = newTheme.colors.text
    		apply(self._value, false)
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    function Toggle:SetValue(v)
    	if type(v) == "boolean" then
    		self._value = v
    	end
    end
    
    function Toggle:GetValue()
    	return self._value
    end
    
    return Toggle
    
  end
  __modules["components/StatusBar"] = function(require, script)
    -- StatusBar component: bottom bar showing status text and indicators
    -- Props:
    -- Text (string)
    -- Sandbox ("Sandboxed"|"Unsafe"|"Offline"|"Online")
    -- Size (UDim2) default (520, 24)
    -- Parent (Instance)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local StatusBar = Base.extend({})
    
    local function indicatorColor(state, theme)
    	local t = theme.colors
    	if state == "Sandboxed" then return t.success end
    	if state == "Online" then return t.primary end
    	if state == "Unsafe" then return t.error end
    	return t.warning -- Offline or unknown
    end
    
    function StatusBar.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, StatusBar)
    
    	local theme = Theme.current()
    	local root = Util.Create("Frame", {
    		Name = "MintStatusBar",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = props.Size or UDim2.fromOffset(520, 24),
    	})
    	self:_own(root)
    	Util.Roundify(root, 6, theme.colors.border, 0.9)
    	Util.Padding(root, 6)
    
    	local text = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, -80, 1, 0),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		Text = tostring(props.Text or "Ready"),
    		TextColor3 = theme.colors.text,
    		Font = Enum.Font.Gotham,
    		TextSize = 12,
    	})
    	text.Parent = root
    
    	local right = Util.Create("Frame", { BackgroundTransparency = 1, Size = UDim2.new(0, 80, 1, 0), Position = UDim2.new(1, -80, 0, 0) })
    	right.Parent = root
    
    	local dot = Util.Create("Frame", { BackgroundColor3 = indicatorColor(props.Sandbox or "Offline", theme), BorderSizePixel = 0, Size = UDim2.fromOffset(10,10), Position = UDim2.new(0,0,0.5,-5) })
    	Util.Roundify(dot, 5)
    	dot.Parent = right
    
    	local label = Util.Create("TextLabel", { BackgroundTransparency = 1, Size = UDim2.new(1, -16, 1, 0), Position = UDim2.new(0, 16, 0, 0), TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center, Text = tostring(props.Sandbox or "Offline"), Font=Enum.Font.Gotham, TextSize=12, TextColor3 = theme.colors.textMuted })
    	label.Parent = right
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		text.TextColor3 = newTheme.colors.text
    		dot.BackgroundColor3 = indicatorColor(label.Text, newTheme)
    		label.TextColor3 = newTheme.colors.textMuted
    	end))
    
    	function self:SetText(t)
    		text.Text = tostring(t)
    	end
    	function self:SetSandbox(state)
    		label.Text = tostring(state)
    		dot.BackgroundColor3 = indicatorColor(state, Theme.current())
    	end
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return StatusBar
    
  end
  __modules["components/Modal"] = function(require, script)
    -- Modal dialog component: overlay with a centered panel
    -- Props:
    -- Title (string)
    -- Content (Instance | string)
    -- Buttons: array of { text=string, style='Primary'|'Secondary', action=function() } (order left->right)
    -- Size (UDim2) panel size, default (360, 180)
    -- Parent (Instance)
    -- Returns { Instance, Open(), Close(), SetContent(inst|string) }
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Modal = Base.extend({})
    
    function Modal.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Modal)
    
    	local theme = Theme.current()
    
    	local overlay = Util.Create("Frame", {
    		Name = "MintModalOverlay",
    		BackgroundColor3 = Color3.fromRGB(0,0,0),
    		BackgroundTransparency = 1,
    		BorderSizePixel = 0,
    		Size = UDim2.fromScale(1,1),
    		Visible = false,
    		ZIndex = 10000,
    	})
    	self:_own(overlay)
    
    	local panel = Util.Create("Frame", {
    		Name = "Panel",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		AnchorPoint = Vector2.new(0.5,0.5),
    		Position = UDim2.fromScale(0.5, 0.5),
    		Size = props.Size or UDim2.fromOffset(360, 180),
    		ZIndex = overlay.ZIndex + 1,
    	})
    	Util.Roundify(panel, 10, theme.colors.border, 0.9)
    	Util.Padding(panel, 10)
    	panel.Parent = overlay
    	self:_own(panel)
    
    	local title = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 0, 22),
    		Text = tostring(props.Title or ""),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		TextColor3 = theme.colors.text,
    		Font = Enum.Font.GothamBold,
    		TextSize = 16,
    	})
    	title.Parent = panel
    
    	local contentArea = Util.Create("Frame", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 1, -60),
    		Position = UDim2.new(0, 0, 0, 26),
    		ClipsDescendants = true,
    	})
    	contentArea.Parent = panel
    
    	local footer = Util.Create("Frame", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 0, 28),
    		Position = UDim2.new(0, 0, 1, -28),
    	})
    	footer.Parent = panel
    	local btnLayout = Util.HList(footer, 8, Enum.VerticalAlignment.Center)
    	btnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
    
    	local function setContent(value)
    		for _, ch in ipairs(contentArea:GetChildren()) do
    			ch:Destroy()
    		end
    		if typeof(value) == "Instance" then
    			value.Parent = contentArea
    		elseif type(value) == "string" then
    			local lbl = Util.Create("TextLabel", {
    				BackgroundTransparency = 1,
    				Size = UDim2.new(1, 0, 1, 0),
    				TextWrapped = true,
    				TextXAlignment = Enum.TextXAlignment.Left,
    				TextYAlignment = Enum.TextYAlignment.Top,
    				Text = value,
    				TextColor3 = theme.colors.text,
    				Font = Enum.Font.Gotham,
    				TextSize = 14,
    			})
    			lbl.Parent = contentArea
    		end
    	end
    	setContent(props.Content)
    	self.SetContent = setContent
    
    	local function addButtons(buttons)
    		for _, b in ipairs(buttons or {}) do
    			local btn = Util.Create("TextButton", {
    				AutoButtonColor = false,
    				BackgroundColor3 = (b.style == "Secondary") and theme.colors.inputBg or theme.colors.primary,
    				BorderSizePixel = 0,
    				Size = UDim2.fromOffset(88, 28),
    				Text = tostring(b.text or "OK"),
    				TextColor3 = (b.style == "Secondary") and theme.colors.text or Color3.new(1,1,1),
    				Font = Enum.Font.GothamSemibold,
    				TextSize = 14,
    			})
    			Util.Roundify(btn, 6, theme.colors.border, 0.8)
    			btn.Parent = footer
    			self:_trackConn(btn.MouseButton1Click:Connect(function()
    				if type(b.action) == "function" then b.action() end
    				self:Close()
    			end))
    		end
    	end
    	addButtons(props.Buttons)
    
    	function self:Open()
    		overlay.Visible = true
    		overlay.BackgroundTransparency = 1
    		Animator.tween(overlay, Animator.Durations.Normal, { BackgroundTransparency = 0.35 })
    		panel.Size = UDim2.fromOffset((props.Size or UDim2.fromOffset(360,180)).X.Offset * 0.95, (props.Size or UDim2.fromOffset(360,180)).Y.Offset * 0.95)
    		Animator.tween(panel, Animator.Durations.Normal, { Size = props.Size or UDim2.fromOffset(360,180) })
    	end
    
    	function self:Close()
    		Animator.tween(overlay, Animator.Durations.Fast, { BackgroundTransparency = 1 })
    		task.delay(Animator.Durations.Fast + 0.05, function()
    			overlay.Visible = false
    		end)
    	end
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		panel.BackgroundColor3 = newTheme.colors.surface
    		title.TextColor3 = newTheme.colors.text
    	end))
    
    	self.Instance = overlay
    	self.Panel = panel
    	if props.Parent then overlay.Parent = props.Parent end
    	return self
    end
    
    return Modal
    
  end
  __modules["core/ThemeManager"] = function(require, script)
    -- ThemeManager: handles light/dark themes and reactive updates
    local Event = require(script.Parent.Event)
    
    local ThemeManager = {}
    
    local themes = {
    	Dark = {
    		name = "Dark",
    		colors = {
    			background = Color3.fromRGB(18, 18, 20),
    			surface = Color3.fromRGB(29, 29, 33),
    			primary = Color3.fromRGB(93, 169, 255),
    			primaryVariant = Color3.fromRGB(65, 135, 217),
    			accent = Color3.fromRGB(255, 128, 64),
    			text = Color3.fromRGB(236, 236, 236),
    			textMuted = Color3.fromRGB(180, 180, 185),
    			border = Color3.fromRGB(50, 50, 55),
    			inputBg = Color3.fromRGB(24, 24, 27),
    			success = Color3.fromRGB(72, 199, 116),
    			warning = Color3.fromRGB(255, 204, 0),
    			error = Color3.fromRGB(255, 99, 95),
    		},
    	},
    	Light = {
    		name = "Light",
    		colors = {
    			background = Color3.fromRGB(245, 246, 248),
    			surface = Color3.fromRGB(255, 255, 255),
    			primary = Color3.fromRGB(0, 122, 255),
    			primaryVariant = Color3.fromRGB(0, 96, 204),
    			accent = Color3.fromRGB(255, 149, 0),
    			text = Color3.fromRGB(28, 28, 30),
    			textMuted = Color3.fromRGB(99, 99, 102),
    			border = Color3.fromRGB(226, 226, 229),
    			inputBg = Color3.fromRGB(248, 249, 251),
    			success = Color3.fromRGB(48, 209, 88),
    			warning = Color3.fromRGB(255, 214, 10),
    			error = Color3.fromRGB(255, 69, 58),
    		},
    	},
    }
    
    ThemeManager._current = themes.Dark
    ThemeManager.changed = Event.new()
    
    function ThemeManager.current()
    	return ThemeManager._current
    end
    
    function ThemeManager.get(name)
    	return themes[name]
    end
    
    function ThemeManager.set(name)
    	local t = themes[name]
    	if not t then return false end
    	ThemeManager._current = t
    	ThemeManager.changed:Fire(t)
    	return true
    end
    
    function ThemeManager.toggle()
    	if ThemeManager._current == themes.Dark then
    		ThemeManager.set("Light")
    	else
    		ThemeManager.set("Dark")
    	end
    end
    
    -- Allow custom theme registration
    function ThemeManager.register(name, themeTable)
    	assert(type(themeTable) == "table" and themeTable.colors, "Theme must be a table with colors field")
    	themeTable.name = name
    	themes[name] = themeTable
    	return themeTable
    end
    
    return ThemeManager
    
  end
  __modules["components/VariableInspector"] = function(require, script)
    -- VariableInspector component: inspect and edit variables in realtime
    -- Props:
    -- Data (table) or Provider (function -> table)
    -- OnChanged(path, newValue) callback when user edits a value
    -- RefreshInterval (number) seconds to auto-refresh when Provider set
    -- Size (UDim2) default (520, 260)
    -- Parent (Instance)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Toggle = require(script.Parent.Toggle)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local VariableInspector = Base.extend({})
    
    local function isArray(t)
    	local i = 0
    	for k, _ in pairs(t) do
    		if typeof(k) ~= "number" then return false end
    		i = math.max(i, k)
    	end
    	return i > 0
    end
    
    function VariableInspector.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, VariableInspector)
    	self.Data = props.Data or {}
    	self.Provider = props.Provider
    	self.OnChanged = props.OnChanged
    	self.RefreshInterval = props.RefreshInterval or 1
    
    	local theme = Theme.current()
    	local root = Util.Create("Frame", {
    		Name = "MintVariableInspector",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = props.Size or UDim2.fromOffset(520, 260),
    	})
    	self:_own(root)
    	Util.Roundify(root, 8, theme.colors.border, 0.9)
    	Util.Padding(root, 8)
    
    	local list = Util.Create("ScrollingFrame", {
    		BackgroundTransparency = 1,
    		BorderSizePixel = 0,
    		ScrollBarThickness = 6,
    		CanvasSize = UDim2.new(0,0,0,0),
    		Size = UDim2.new(1, 0, 1, 0),
    	})
    	list.Parent = root
    	local uiList = Util.VList(list, 4, Enum.HorizontalAlignment.Left)
    	self:_trackConn(uiList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    		list.CanvasSize = UDim2.new(0,0,0, uiList.AbsoluteContentSize.Y + 8)
    	end))
    
    	local function addRow(path, key, value, depth)
    		depth = depth or 0
    		local row = Util.Create("Frame", { BackgroundColor3 = theme.colors.inputBg, BorderSizePixel = 0, Size = UDim2.new(1, -6, 0, 28) })
    		Util.Roundify(row, 6, theme.colors.border, 0.8)
    		row.Parent = list
    
    		local keyLbl = Util.Create("TextLabel", {
    			BackgroundTransparency = 1,
    			Position = UDim2.new(0, 8 + depth*16, 0, 0),
    			Size = UDim2.new(0, 200 - depth*16, 1, 0),
    			TextXAlignment = Enum.TextXAlignment.Left,
    			TextYAlignment = Enum.TextYAlignment.Center,
    			Text = tostring(key),
    			TextColor3 = theme.colors.text,
    			Font = Enum.Font.Gotham,
    			TextSize = 13,
    		})
    		keyLbl.Parent = row
    
    		local valueType = typeof(value)
    		if valueType == "boolean" then
    			local t = Toggle.new({ Value = value })
    			t.Instance.Size = UDim2.fromOffset(60, 24)
    			t.Instance.Position = UDim2.new(1, -68, 0.5, -12)
    			t.Instance.Parent = row
    			t.Instance.BackgroundTransparency = 1
    			t.Instance:FindFirstChild("Track").Size = UDim2.fromOffset(42, 22)
    			t.Instance:FindFirstChild("Track").Position = UDim2.new(1, -44, 0.5, -11)
    			t.Instance:FindFirstChild("Track").AnchorPoint = Vector2.new(0,0)
    			t.Instance:FindFirstChild("Track").ZIndex = row.ZIndex + 1
    			t.Instance:FindFirstChild("Track"):FindFirstChild("Dot").ZIndex = row.ZIndex + 2
    			t.Instance:FindFirstChild("Track"):FindFirstChild("Dot").Size = UDim2.fromOffset(16,16)
    			-- rewire change callback
    			self:_trackConn(t.Instance.Track.MouseButton1Click:Connect(function()
    				local newVal = not value
    				if self.OnChanged then pcall(self.OnChanged, path, newVal) end
    				value = newVal
    			end))
    		elseif valueType == "number" or valueType == "string" then
    			local box = Util.Create("TextBox", { BackgroundColor3 = theme.colors.surface, BorderSizePixel=0, Size=UDim2.new(0, 160, 0, 22), Position = UDim2.new(1, -168, 0.5, -11), Text = tostring(value), TextXAlignment=Enum.TextXAlignment.Left, TextYAlignment=Enum.TextYAlignment.Center, TextColor3 = theme.colors.text, Font = Enum.Font.Gotham, TextSize = 13 })
    			Util.Roundify(box, 6, theme.colors.border, 0.8); Util.Padding(box, 6)
    			box.Parent = row
    			self:_trackConn(box.FocusLost:Connect(function()
    				local val = box.Text
    				if valueType == "number" then val = tonumber(val) or value end
    				if self.OnChanged then pcall(self.OnChanged, path, val) end
    				value = val
    			end))
    		elseif valueType == "table" then
    			local btn = Util.Create("TextButton", { AutoButtonColor=false, BackgroundTransparency=1, Size = UDim2.new(1, -8, 1, 0), Position = UDim2.new(0, 4, 0, 0), TextXAlignment=Enum.TextXAlignment.Left, Text = "▶", TextColor3 = theme.colors.textMuted, Font = Enum.Font.GothamBold, TextSize=13 })
    			btn.Parent = row
    			local expanded = false
    			self:_trackConn(btn.MouseButton1Click:Connect(function()
    				expanded = not expanded
    				btn.Text = expanded and "▼" or "▶"
    				if expanded then
    					for k, v in pairs(value) do
    						addRow(path .. "." .. tostring(k), k, v, depth + 1)
    					end
    				else
    					-- rebuild entire view to collapse properly
    					VariableInspector._render(self)
    				end
    			end))
    		else
    			local lbl = Util.Create("TextLabel", { BackgroundTransparency=1, Size=UDim2.new(0, 160, 1, 0), Position=UDim2.new(1,-168,0,0), TextXAlignment=Enum.TextXAlignment.Right, TextYAlignment=Enum.TextYAlignment.Center, Text = tostring(value), TextColor3 = theme.colors.textMuted, Font=Enum.Font.Gotham, TextSize=13 })
    			lbl.Parent = row
    		end
    	end
    
    	function VariableInspector:_render()
    		list:ClearAllChildren()
    		local data = self.Data
    		if self.Provider then
    			local ok, res = pcall(self.Provider)
    			if ok and type(res) == "table" then data = res end
    		end
    		for k, v in pairs(data) do
    			addRow(tostring(k), k, v, 0)
    		end
    	end
    
    	self:_render()
    
    	if self.Provider then
    		local running = true
    		self:_trackCleanup(function() running = false end)
    		task.spawn(function()
    			while running do
    				task.wait(self.RefreshInterval)
    				self:_render()
    			end
    		end)
    	end
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		self:_render()
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    function VariableInspector:SetData(t)
    	self.Data = t or {}
    	self:_render()
    end
    
    return VariableInspector
    
  end
  __modules["components/QueueManager"] = function(require, script)
    -- QueueManager component: visual manager for a Queue of scripts/tasks
    -- Props:
    -- Queue (Queue instance) required
    -- OnSelect(item)
    -- Actions map optional: { Start='ActionName', Pause='ActionName', Stop='ActionName', Remove='ActionName' }
    -- Size (UDim2)
    -- Parent (Instance)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local ProgressBar = require(script.Parent.ProgressBar)
    local Registry = require(script.Parent.Parent.core.Registry)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local QueueManager = Base.extend({})
    
    function QueueManager.new(props)
    	props = props or {}
    	assert(props.Queue, "QueueManager requires props.Queue (Queue instance)")
    	local self = Base.init({})
    	setmetatable(self, QueueManager)
    	self.Queue = props.Queue
    	self.Actions = props.Actions or {}
    	self.OnSelect = props.OnSelect
    
    	local theme = Theme.current()
    	local root = Util.Create("Frame", {
    		Name = "MintQueueManager",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = props.Size or UDim2.fromOffset(520, 240),
    	})
    	self:_own(root)
    	Util.Roundify(root, 8, theme.colors.border, 0.9)
    	Util.Padding(root, 8)
    
    	local list = Util.Create("ScrollingFrame", {
    		BackgroundTransparency = 1,
    		BorderSizePixel = 0,
    		ScrollBarThickness = 6,
    		CanvasSize = UDim2.new(0,0,0,0),
    		Size = UDim2.new(1, 0, 1, 0),
    	})
    	list.Parent = root
    	local uiList = Util.VList(list, 6, Enum.HorizontalAlignment.Left)
    	self:_trackConn(uiList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    		list.CanvasSize = UDim2.new(0,0,0, uiList.AbsoluteContentSize.Y + 8)
    	end))
    
    	local function statusColor(st)
    		local c = Theme.current().colors
    		if st == 'running' then return c.primary
    		elseif st == 'paused' then return c.warning
    		elseif st == 'done' then return c.success
    		elseif st == 'failed' then return c.error
    		elseif st == 'stopped' then return c.textMuted
    		else return c.border end
    	end
    
    	local rows = {}
    
    	local function render()
    		list:ClearAllChildren()
    		rows = {}
    		for _, item in ipairs(self.Queue:list()) do
    			local row = Util.Create("Frame", { BackgroundColor3 = theme.colors.inputBg, BorderSizePixel = 0, Size = UDim2.new(1, -6, 0, 56) })
    			Util.Roundify(row, 6, theme.colors.border, 0.8)
    			row.Parent = list
    			local title = Util.Create("TextLabel", { BackgroundTransparency=1, Size = UDim2.new(1, -200, 0, 20), TextXAlignment=Enum.TextXAlignment.Left, Text = tostring(item.name), Font=Enum.Font.GothamBold, TextSize=14, TextColor3 = theme.colors.text })
    			title.Parent = row
    			local status = Util.Create("TextLabel", { BackgroundTransparency=1, Size = UDim2.new(0, 100, 0, 20), Position = UDim2.new(1,-100,0,0), TextXAlignment=Enum.TextXAlignment.Right, Text = string.upper(item.status), Font=Enum.Font.Gotham, TextSize=12, TextColor3 = statusColor(item.status) })
    			status.Parent = row
    
    			local pb = ProgressBar.new({ Value = item.progress or 0 })
    			pb.Instance.Size = UDim2.new(1, -6, 0, 8)
    			pb.Instance.Position = UDim2.new(0, 3, 0, 26)
    			pb.Instance.Parent = row
    
    			local controls = Util.Create("Frame", { BackgroundTransparency=1, Position = UDim2.new(1, -190, 0, 0), Size = UDim2.fromOffset(180, 24) })
    			controls.Parent = row
    			local h = Util.HList(controls, 6, Enum.VerticalAlignment.Center)
    			h.HorizontalAlignment = Enum.HorizontalAlignment.Right
    			local function makeBtn(txt)
    				local b = Util.Create("TextButton", { AutoButtonColor=false, BackgroundColor3=theme.colors.surface, BorderSizePixel=0, Size=UDim2.fromOffset(40, 22), Text=txt, Font=Enum.Font.Gotham, TextSize=12, TextColor3=theme.colors.text })
    				Util.Roundify(b, 4, theme.colors.border, 0.8)
    				b.Parent = controls
    				return b
    			end
    			local bPlay = makeBtn("Run")
    			local bPause = makeBtn("Pause")
    			local bStop = makeBtn("Stop")
    			local bDel = makeBtn("X")
    
    			self:_trackConn(bPlay.MouseButton1Click:Connect(function()
    				self.Queue:start(item.id)
    				if self.Actions.Start then Registry.invoke(self.Actions.Start, item) end
    			end))
    			self:_trackConn(bPause.MouseButton1Click:Connect(function()
    				self.Queue:pause(item.id)
    				if self.Actions.Pause then Registry.invoke(self.Actions.Pause, item) end
    			end))
    			self:_trackConn(bStop.MouseButton1Click:Connect(function()
    				self.Queue:stop(item.id)
    				if self.Actions.Stop then Registry.invoke(self.Actions.Stop, item) end
    			end))
    			self:_trackConn(bDel.MouseButton1Click:Connect(function()
    				self.Queue:remove(item.id)
    				if self.Actions.Remove then Registry.invoke(self.Actions.Remove, item) end
    			end))
    
    			self:_trackConn(row.InputBegan:Connect(function(input)
    				if input.UserInputType == Enum.UserInputType.MouseButton1 then
    					if self.OnSelect then pcall(self.OnSelect, item) end
    				end
    			end))
    
    			rows[#rows+1] = row
    		end
    	end
    
    	render()
    
    	self:_trackConn(props.Queue.changed:Connect(function(op, item)
    		render()
    	end))
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		render()
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return QueueManager
    
  end
  __modules["components/Panel"] = function(require, script)
    -- Panel component: a themed container
    -- Props:
    -- Size (UDim2)
    -- Padding (number) optional, default 8
    -- Layout ("Vertical"|"Horizontal") optional
    -- Parent (Instance) optional
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Panel = Base.extend({})
    
    function Panel.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Panel)
    	self.Props = props
    
    	local theme = Theme.current()
    	local panel = Util.Create("Frame", {
    		Name = "MintPanel",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 1,
    		BorderColor3 = theme.colors.border,
    		Size = props.Size or UDim2.fromOffset(300, 400),
    	})
    	self:_own(panel)
    
    	Util.Roundify(panel, 8, theme.colors.border, 1)
    	Util.Padding(panel, props.Padding or 8)
    
    	if props.Layout == "Vertical" then
    		Util.VList(panel, props.Padding or 8, Enum.HorizontalAlignment.Left)
    	elseif props.Layout == "Horizontal" then
    		Util.HList(panel, props.Padding or 8, Enum.VerticalAlignment.Top)
    	end
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		panel.BackgroundColor3 = newTheme.colors.surface
    		panel.BorderColor3 = newTheme.colors.border
    		local stroke = panel:FindFirstChildOfClass("UIStroke")
    		if stroke then
    			stroke.Color = newTheme.colors.border
    		end
    	end))
    
    	self.Instance = panel
    	if props.Parent then panel.Parent = props.Parent end
    	return self
    end
    
    return Panel
    
  end
  __modules["components/ExecutionControls"] = function(require, script)
    -- ExecutionControls: Play/Pause/Stop control strip with visual state
    -- Props:
    -- State ('stopped'|'running'|'paused') default 'stopped'
    -- OnPlay(), OnPause(), OnStop() callbacks optional
    -- Actions: { Play='ActionName', Pause='ActionName', Stop='ActionName' } optional for Registry
    -- Parent (Instance)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Registry = require(script.Parent.Parent.core.Registry)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local ExecutionControls = Base.extend({})
    
    function ExecutionControls.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, ExecutionControls)
    	self.State = props.State or 'stopped'
    	self.Actions = props.Actions or {}
    	self.OnPlay = props.OnPlay
    	self.OnPause = props.OnPause
    	self.OnStop = props.OnStop
    
    	local theme = Theme.current()
    	local root = Util.Create("Frame", {
    		Name = "MintExecutionControls",
    		BackgroundTransparency = 1,
    		Size = UDim2.fromOffset(220, 32),
    	})
    	self:_own(root)
    
    	local layout = Util.HList(root, 8, Enum.VerticalAlignment.Center)
    	layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    
    	local function makeBtn(txt)
    		local b = Util.Create("TextButton", {
    			AutoButtonColor = false,
    			BackgroundColor3 = theme.colors.inputBg,
    			BorderSizePixel = 0,
    			Size = UDim2.fromOffset(64, 28),
    			Text = txt,
    			TextColor3 = theme.colors.text,
    			Font = Enum.Font.GothamSemibold,
    			TextSize = 14,
    		})
    		Util.Roundify(b, 6, theme.colors.border, 0.8)
    		return b
    	end
    
    	local play = makeBtn("▶ Run")
    	local pause = makeBtn("⏸ Pause")
    	local stop = makeBtn("⏹ Stop")
    	play.Parent = root; pause.Parent = root; stop.Parent = root
    
    	local function applyState()
    		local s = self.State
    		local activeColor = theme.colors.primary
    		Animator.tween(play, Animator.Durations.Fast, { BackgroundColor3 = (s=='running') and activeColor or theme.colors.inputBg, TextColor3 = (s=='running') and Color3.new(1,1,1) or theme.colors.text })
    		Animator.tween(pause, Animator.Durations.Fast, { BackgroundColor3 = (s=='paused') and activeColor or theme.colors.inputBg, TextColor3 = (s=='paused') and Color3.new(1,1,1) or theme.colors.text })
    		Animator.tween(stop, Animator.Durations.Fast, { BackgroundColor3 = (s=='stopped') and activeColor or theme.colors.inputBg, TextColor3 = (s=='stopped') and Color3.new(1,1,1) or theme.colors.text })
    	end
    	applyState()
    
    	local function safeCall(fn) if fn then local ok,e=pcall(fn); if not ok then warn(e) end end end
    
    	self:_trackConn(play.MouseButton1Click:Connect(function()
    		self.State = 'running'; applyState()
    		safeCall(self.OnPlay)
    		if self.Actions.Play then Registry.invoke(self.Actions.Play) end
    	end))
    	self:_trackConn(pause.MouseButton1Click:Connect(function()
    		self.State = 'paused'; applyState()
    		safeCall(self.OnPause)
    		if self.Actions.Pause then Registry.invoke(self.Actions.Pause) end
    	end))
    	self:_trackConn(stop.MouseButton1Click:Connect(function()
    		self.State = 'stopped'; applyState()
    		safeCall(self.OnStop)
    		if self.Actions.Stop then Registry.invoke(self.Actions.Stop) end
    	end))
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		theme = newTheme
    		applyState()
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return ExecutionControls
    
  end
  __modules["core/Hotkeys"] = function(require, script)
    -- Hotkeys: register keyboard shortcuts mapped to Registry actions or callbacks
    -- API:
    -- Hotkeys.bind("Ctrl+R", function() ... end) or Hotkeys.bind("Ctrl+R", { Action = "RunScript" })
    -- Hotkeys.unbind("Ctrl+R")
    -- Hotkeys.clear()
    -- Hotkeys.enabled(true/false)
    
    local UserInputService = game:GetService("UserInputService")
    
    local Registry = require(script.Parent.Registry)
    
    local Hotkeys = {}
    
    local _enabled = true
    local _bindings = {} -- comboId -> { callback=function, actionName=string }
    local _conn
    
    local function normalizeKey(key)
    	key = string.upper(key)
    	key = key:gsub("CTRL", "LeftControl"):gsub("CMD", "LeftMeta"):gsub("ALT", "LeftAlt")
    	return key
    end
    
    local function parseCombo(combo)
    	-- Supports: Ctrl+Shift+K, Alt+R, F5
    	local parts = {}
    	for token in string.gmatch(combo, "[^+]+") do
    		parts[#parts+1] = normalizeKey(token)
    	end
    	return parts
    end
    
    local function comboId(parts)
    	table.sort(parts)
    	return table.concat(parts, "+")
    end
    
    local function currentModifiers()
    	local parts = {}
    	if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then parts[#parts+1] = "LeftControl" end
    	if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift) then parts[#parts+1] = "LeftShift" end
    	if UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) or UserInputService:IsKeyDown(Enum.KeyCode.RightAlt) then parts[#parts+1] = "LeftAlt" end
    	return parts
    end
    
    local function ensureListener()
    	if _conn then return end
    	_conn = UserInputService.InputBegan:Connect(function(input, processed)
    		if not _enabled or processed then return end
    		if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
    		-- Ignore when typing in a TextBox
    		if UserInputService:GetFocusedTextBox() ~= nil then return end
    		local parts = currentModifiers()
    		local key = input.KeyCode.Name
    		if key ~= "Unknown" then parts[#parts+1] = key end
    		local id = comboId(parts)
    		local binding = _bindings[id]
    		if binding then
    			if binding.callback then
    				binding.callback()
    			elseif binding.actionName then
    				Registry.invoke(binding.actionName)
    			end
    		end
    	end)
    end
    
    function Hotkeys.bind(combo, target)
    	local parts = parseCombo(combo)
    	local id = comboId(parts)
    	if type(target) == "function" then
    		_bindings[id] = { callback = target }
    	elseif type(target) == "table" and type(target.Action) == "string" then
    		_bindings[id] = { actionName = target.Action }
    	else
    		error("Hotkeys.bind requires a function or { Action = name }")
    	end
    	ensureListener()
    end
    
    function Hotkeys.unbind(combo)
    	local id = comboId(parseCombo(combo))
    	_bindings[id] = nil
    end
    
    function Hotkeys.clear()
    	_bindings = {}
    end
    
    function Hotkeys.enabled(v)
    	_enabled = v and true or false
    end
    
    return Hotkeys
    
  end
  __modules["init"] = function(require, script)
    -- MinT_UI_Lib_Roblox
    -- Entry point for the library. Provides factory methods and exports core utilities and components.
    --
    -- How to use (see README for full guide):
    -- local Mint = require(path.to.Mint)
    -- local app = Mint.newApp(player:WaitForChild("PlayerGui"))
    -- app:mount() -- creates a ScreenGui and responsive scaling
    --
    -- local btn = Mint.components.Button.new({
    --     Text = "Run",
    --     Action = "RunScript", -- optional: name in the Registry
    --     OnClick = function()
    --         print("Clicked Run")
    --     end,
    -- })
    -- btn.Instance.Parent = app.Root -- attach to your layout container
    --
    -- Mint.Registry.register("RunScript", function()
    --     -- do work
    -- end)
    
    local Mint = {}
    
    Mint._version = "0.1.0"
    
    -- Core
    Mint.Util = require(script.core.Util)
    Mint.Event = require(script.core.Event)
    Mint.Animator = require(script.core.Animator)
    Mint.Responsive = require(script.core.Responsive)
    Mint.Registry = require(script.core.Registry)
    Mint.ThemeManager = require(script.core.ThemeManager)
    Mint.ErrorHandler = require(script.core.ErrorHandler)
    Mint.Hotkeys = require(script.core.Hotkeys)
    Mint.LogManager = require(script.core.LogManager)
    Mint.Storage = require(script.core.Storage)
    Mint.Validator = require(script.core.Validator)
    Mint.Queue = require(script.core.Queue)
    
    -- Components
    Mint.components = {
    	Button = require(script.components.Button),
    	Toggle = require(script.components.Toggle),
    	Slider = require(script.components.Slider),
    	TextInput = require(script.components.TextInput),
    	Dropdown = require(script.components.Dropdown),
    	Label = require(script.components.Label),
    	Panel = require(script.components.Panel),
    	Notification = require(script.components.Notification),
    	ProgressBar = require(script.components.ProgressBar),
    	CodeEditor = require(script.components.CodeEditor),
    	Console = require(script.components.Console),
    	Tabs = require(script.components.Tabs),
    	Modal = require(script.components.Modal),
    	StatusBar = require(script.components.StatusBar),
    	Toolbar = require(script.components.Toolbar),
    	ExecutionControls = require(script.components.ExecutionControls),
    	QueueManager = require(script.components.QueueManager),
    	VariableInspector = require(script.components.VariableInspector),
    	PerformanceMonitor = require(script.components.PerformanceMonitor),
    }
    
    -- App factory: creates a ScreenGui + responsive scaling + theme hookup
    function Mint.newApp(parent, config)
    	config = config or {}
    	local Util = Mint.Util
    	local ThemeManager = Mint.ThemeManager
    	local Responsive = Mint.Responsive
    	local Notification = require(script.components.Notification)
    
    	local app = {}
    
    	app.Parent = parent
    	app.Config = {
    		Name = config.Name or "MintUI",
    		ZIndexBehavior = config.ZIndexBehavior or Enum.ZIndexBehavior.Sibling,
    		IgnoreGuiInset = config.IgnoreGuiInset ~= false,
    		DisplayOrder = config.DisplayOrder or 0,
    	}
    
    	function app:mount()
    		if self.Root then return self.Root end
    		local gui = Util.Create("ScreenGui", {
    			Name = self.Config.Name,
    			ZIndexBehavior = self.Config.ZIndexBehavior,
    			IgnoreGuiInset = self.Config.IgnoreGuiInset,
    			DisplayOrder = self.Config.DisplayOrder,
    			ResetOnSpawn = false,
    		}, {
    			Util.Create("Folder", { Name = "Layers" }),
    		})
    		gui.Parent = self.Parent
    
    		self.Root = gui
    		self.Scale = Responsive.Attach(gui)
    
    		-- Attach Notification system for user feedback
    		Notification.Attach(gui, config.Notifications)
    
    		-- Apply current theme background to the root by adding a full-size Frame layer
    		local bg = Util.Create("Frame", {
    			Name = "AppBackground",
    			BackgroundTransparency = 0,
    			BorderSizePixel = 0,
    			Size = UDim2.fromScale(1, 1),
    			ZIndex = 0,
    		})
    		bg.Parent = gui
    
    		local function applyTheme(theme)
    			bg.BackgroundColor3 = theme.colors.background
    		end
    		applyTheme(ThemeManager.current())
    		ThemeManager.changed:Connect(applyTheme)
    
    		return gui
    	end
    
    	function app:unmount()
    		if self.Root then
    			self.Root:Destroy()
    			self.Root = nil
    			self.Scale = nil
    		end
    	end
    
    	-- Theme helpers for convenience
    	function app:setTheme(name)
    		return ThemeManager.set(name)
    	end
    	function app:toggleTheme()
    		ThemeManager.toggle()
    	end
    
    	-- Forward notify helper
    	function app:notify(level, message, opts)
    		local gui = self.Root
    		if gui then
    			require(script.components.Notification).Notify(level, message, opts)
    		end
    	end
    
    	return app
    end
    
    return Mint
    
  end
  __modules["components/PerformanceMonitor"] = function(require, script)
    -- PerformanceMonitor component: displays memory usage and a run timer
    -- Props:
    -- Size (UDim2) default (260, 60)
    -- Parent (Instance)
    -- Provide external controls: Start(), Pause(), Stop() to manage timer
    
    local RunService = game:GetService("RunService")
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local PerformanceMonitor = Base.extend({})
    
    local function formatMemMB(kb)
    	local mb = (kb or 0) / 1024
    	return string.format("%.1f MB", mb)
    end
    
    local function formatTime(sec)
    	sec = math.max(0, math.floor(sec))
    	local h = math.floor(sec / 3600); sec = sec % 3600
    	local m = math.floor(sec / 60); local s = sec % 60
    	if h > 0 then return string.format("%02d:%02d:%02d", h, m, s) end
    	return string.format("%02d:%02d", m, s)
    end
    
    function PerformanceMonitor.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, PerformanceMonitor)
    	self._running = false
    	self._startTime = 0
    	self._accumPaused = 0
    	self._pauseStarted = 0
    
    	local theme = Theme.current()
    	local root = Util.Create("Frame", {
    		Name = "MintPerformanceMonitor",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = props.Size or UDim2.fromOffset(260, 60),
    	})
    	self:_own(root)
    	Util.Roundify(root, 8, theme.colors.border, 0.9)
    	Util.Padding(root, 8)
    
    	local vlist = Util.VList(root, 4, Enum.HorizontalAlignment.Left)
    
    	local memLabel = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 0, 18),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		Text = "Memory: ...",
    		TextColor3 = theme.colors.text,
    		Font = Enum.Font.Gotham,
    		TextSize = 13,
    	})
    	memLabel.Parent = root
    
    	local timeLabel = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 0, 18),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		Text = "Time: 00:00",
    		TextColor3 = theme.colors.text,
    		Font = Enum.Font.Gotham,
    		TextSize = 13,
    	})
    	timeLabel.Parent = root
    
    	local hbConn
    	local function update()
    		-- Memory via collectgarbage("count") in KB
    		local kb = collectgarbage("count")
    		memLabel.Text = "Memory: " .. formatMemMB(kb)
    		if self._running then
    			local t = os.clock() - self._startTime - self._accumPaused
    			timeLabel.Text = "Time: " .. formatTime(t)
    		end
    	end
    
    	local function start()
    		if self._running then return end
    		self._running = true
    		if self._startTime == 0 then self._startTime = os.clock() end
    		if self._pauseStarted > 0 then
    			self._accumPaused += (os.clock() - self._pauseStarted)
    			self._pauseStarted = 0
    		end
    		if not hbConn then hbConn = RunService.Heartbeat:Connect(update); self:_trackConn(hbConn) end
    	end
    
    	local function pause()
    		if not self._running then return end
    		self._running = false
    		self._pauseStarted = os.clock()
    	end
    
    	local function stop()
    		self._running = false
    		self._startTime = 0
    		self._accumPaused = 0
    		self._pauseStarted = 0
    		timeLabel.Text = "Time: 00:00"
    	end
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		memLabel.TextColor3 = newTheme.colors.text
    		timeLabel.TextColor3 = newTheme.colors.text
    	end))
    
    	self.Instance = root
    	self.Start = start
    	self.Pause = pause
    	self.Stop = stop
    	if props.Parent then root.Parent = props.Parent end
    	update()
    	return self
    end
    
    return PerformanceMonitor
    
  end
  __modules["core/ComponentBase"] = function(require, script)
    -- ComponentBase: provides lifecycle and connection/cleanup management
    -- Usage:
    -- local Base = require(script.Parent.ComponentBase)
    -- local MyComp = Base.extend({})
    -- function MyComp.new(props)
    --   local self = Base.init({})
    --   setmetatable(self, MyComp)
    --   ...
    --   self:_own(rootInstance)
    --   self:_trackConn(SomeSignal:Connect(function() ... end))
    --   self:_trackCleanup(function() ... end) -- any extra cleanup
    --   self.Instance = rootInstance
    --   return self
    -- end
    -- Now you can call myComp:Destroy() to disconnect and destroy.
    
    local ComponentBase = {}
    ComponentBase.__index = ComponentBase
    
    function ComponentBase.extend(Class)
    	Class.__index = Class
    	Class._base = ComponentBase
    	return Class
    end
    
    function ComponentBase.init(tbl)
    	tbl = tbl or {}
    	setmetatable(tbl, ComponentBase)
    	tbl._conns = {}
    	tbl._cleanups = {}
    	tbl._owned = {}
    	tbl._destroyed = false
    	return tbl
    end
    
    function ComponentBase:_trackConn(conn)
    	if conn then
    		table.insert(self._conns, conn)
    	end
    	return conn
    end
    
    function ComponentBase:_trackCleanup(fn)
    	if type(fn) == "function" then
    		table.insert(self._cleanups, fn)
    	end
    	return fn
    end
    
    function ComponentBase:_own(inst)
    	if typeof(inst) == "Instance" then
    		table.insert(self._owned, inst)
    	end
    	return inst
    end
    
    function ComponentBase:Destroy()
    	if self._destroyed then return end
    	self._destroyed = true
    	-- Disconnect signal connections
    	for _, c in ipairs(self._conns) do
    		pcall(function()
    			if c and c.Connected ~= nil then
    				if c.Connected then c:Disconnect() end
    			elseif type(c) == "table" and c.Disconnect then
    				c:Disconnect()
    			end
    		end)
    	end
    	self._conns = {}
    	-- Run cleanups
    	for i = #self._cleanups, 1, -1 do
    		local fn = self._cleanups[i]
    		pcall(fn)
    		self._cleanups[i] = nil
    	end
    	self._cleanups = {}
    	-- Destroy owned instances (root first usually last added? destroy all)
    	for i = #self._owned, 1, -1 do
    		local inst = self._owned[i]
    		if inst and inst.Destroy then
    			pcall(function() inst:Destroy() end)
    		end
    		self._owned[i] = nil
    	end
    	self._owned = {}
    	-- Allow subclasses to override OnDestroy if needed
    	if type(self.OnDestroy) == "function" then
    		pcall(function() self:OnDestroy() end)
    	end
    end
    
    return ComponentBase
    
  end
  __modules["components/TextInput"] = function(require, script)
    -- TextInput component
    -- Props:
    -- Placeholder (string)
    -- Text (string) initial
    -- ClearTextOnFocus (boolean)
    -- OnChanged (function:string)
    -- OnSubmitted (function:string)
    -- Validate (function:string -> boolean, string|nil) returns ok, errMsg
    -- Action (string) optional; Registry.invoke(Action, text) on submit
    -- Size (UDim2) default (220, 32)
    -- Parent (Instance) optional
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Registry = require(script.Parent.Parent.core.Registry)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local TextInput = Base.extend({})
    
    function TextInput.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, TextInput)
    	self.Props = props
    	self.Text = props.Text or ""
    
    	local theme = Theme.current()
    
    	local root = Util.Create("Frame", {
    		Name = "MintTextInput",
    		BackgroundTransparency = 1,
    		Size = props.Size or UDim2.fromOffset(220, 32),
    	})
    	self:_own(root)
    
    	local box = Util.Create("TextBox", {
    		Name = "Box",
    		BackgroundColor3 = theme.colors.inputBg,
    		BorderSizePixel = 0,
    		Size = UDim2.new(1, 0, 1, 0),
    		ClearTextOnFocus = props.ClearTextOnFocus == true,
    		Text = self.Text,
    		PlaceholderText = props.Placeholder or "Type here...",
    		TextColor3 = theme.colors.text,
    		PlaceholderColor3 = theme.colors.textMuted,
    		TextSize = 14,
    		Font = Enum.Font.Gotham,
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    	})
    	Util.Roundify(box, 6, theme.colors.border, 0.7)
    	Util.Padding(box, 8)
    	box.Parent = root
    
    	local errorLabel = Util.Create("TextLabel", {
    		Name = "Error",
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 0, 14),
    		Position = UDim2.new(0, 0, 1, 2),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		Text = "",
    		TextColor3 = theme.colors.error,
    		Font = Enum.Font.Gotham,
    		TextSize = 12,
    		TextTransparency = 1,
    	})
    	errorLabel.Parent = root
    
    	local function setError(msg)
    		if msg and msg ~= "" then
    			errorLabel.Text = tostring(msg)
    			Animator.tween(errorLabel, Animator.Durations.Fast, { TextTransparency = 0 })
    			Animator.tween(box, Animator.Durations.Fast, { BackgroundColor3 = Color3.fromRGB(255, 240, 240) })
    		else
    			Animator.tween(errorLabel, Animator.Durations.Fast, { TextTransparency = 1 })
    			Animator.tween(box, Animator.Durations.Fast, { BackgroundColor3 = theme.colors.inputBg })
    		end
    	end
    
    	self:_trackConn(box:GetPropertyChangedSignal("Text"):Connect(function()
    		self.Text = box.Text
    		if props.OnChanged then
    			local ok, err = pcall(props.OnChanged, self.Text)
    			if not ok then warn(err) end
    		end
    		if props.Validate then
    			local ok, errMsg = props.Validate(self.Text)
    			setError(ok and nil or errMsg or "Invalid input")
    		end
    	end))
    
    	self:_trackConn(box.FocusLost:Connect(function(enterPressed)
    		local valid = true
    		if props.Validate then
    			local ok, errMsg = props.Validate(self.Text)
    			valid = ok
    			setError(ok and nil or errMsg or "Invalid input")
    		end
    		if enterPressed and valid then
    			if props.OnSubmitted then
    				local ok, err = pcall(props.OnSubmitted, self.Text)
    				if not ok then warn(err) end
    			end
    			if props.Action then
    				Registry.invoke(props.Action, self.Text)
    			end
    		end
    	end))
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		box.BackgroundColor3 = newTheme.colors.inputBg
    		box.TextColor3 = newTheme.colors.text
    		box.PlaceholderColor3 = newTheme.colors.textMuted
    		errorLabel.TextColor3 = newTheme.colors.error
    	end))
    
    	self.Instance = root
    	self.Box = box
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    function TextInput:SetText(text)
    	self.Text = tostring(text or "")
    	if self.Box then self.Box.Text = self.Text end
    end
    
    return TextInput
    
  end
  __modules["components/Console"] = function(require, script)
    -- Console/Output Panel
    -- Shows logs with color-coded levels, search and clear. Listens to LogManager and ErrorHandler.
    -- Props:
    -- Size (UDim2) default (520, 200)
    -- Levels (table set) to show initially, default { info=true, success=true, warning=true, error=true, debug=true, output=true }
    -- MaxEntries (number) default 500 (display cap)
    -- Parent (Instance)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local LogManager = require(script.Parent.Parent.core.LogManager)
    local ErrorHandler = require(script.Parent.Parent.core.ErrorHandler)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Console = Base.extend({})
    
    local LEVELS = { "info", "success", "warning", "error", "debug", "output" }
    
    local function levelColor(level, theme)
    	local t = theme.colors
    	if level == "success" then return t.success end
    	if level == "warning" then return t.warning end
    	if level == "error" then return t.error end
    	if level == "debug" then return t.accent end
    	if level == "output" then return t.primaryVariant end
    	return t.text
    end
    
    function Console.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Console)
    	self.Levels = props.Levels or { info=true, success=true, warning=true, error=true, debug=true, output=true }
    	self.Search = ""
    	self.MaxEntries = tonumber(props.MaxEntries) or 500
    
    	local theme = Theme.current()
    	local root = Util.Create("Frame", {
    		Name = "MintConsole",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = props.Size or UDim2.fromOffset(520, 240),
    	})
    	self:_own(root)
    	Util.Roundify(root, 8, theme.colors.border, 0.9)
    	Util.Padding(root, 8)
    
    	local header = Util.Create("Frame", { BackgroundTransparency = 1, Size = UDim2.new(1, 0, 0, 24) })
    	header.Parent = root
    	-- Filters row (level toggles)
    	local filters = Util.Create("Frame", { BackgroundTransparency = 1, Size = UDim2.new(1, -60, 1, 0) })
    	filters.Parent = header
    	local fl = Util.HList(filters, 6, Enum.VerticalAlignment.Center)
    	fl.HorizontalAlignment = Enum.HorizontalAlignment.Left
    
    	local function refreshFilterButton(btn, level)
    		local active = self.Levels[level] == true
    		btn.BackgroundColor3 = active and theme.colors.primary or theme.colors.inputBg
    		btn.TextColor3 = active and Color3.new(1,1,1) or theme.colors.text
    		local stroke = btn:FindFirstChildOfClass("UIStroke"); if stroke then stroke.Color = theme.colors.border end
    	end
    
    	local function addFilter(level)
    		local btn = Util.Create("TextButton", { AutoButtonColor=false, BackgroundColor3 = self.Levels[level] and theme.colors.primary or theme.colors.inputBg, BorderSizePixel=0, Size=UDim2.fromOffset(64, 22), Text = level:sub(1,1):upper()..level:sub(2,2), TextColor3 = self.Levels[level] and Color3.new(1,1,1) or theme.colors.text, Font=Enum.Font.Gotham, TextSize=12 })
    		Util.Roundify(btn, 6, theme.colors.border, 0.8)
    		btn.Parent = filters
    		self:_trackConn(btn.MouseButton1Click:Connect(function()
    			self.Levels[level] = not self.Levels[level]
    			refreshFilterButton(btn, level)
    			rebuild()
    		end))
    		refreshFilterButton(btn, level)
    	end
    	for _, lv in ipairs(LEVELS) do addFilter(lv) end
    
    	local search = Util.Create("TextBox", {
    		BackgroundColor3 = theme.colors.inputBg, BorderSizePixel = 0,
    		Size = UDim2.new(0, 160, 1, 0), Position = UDim2.new(1, -212, 0, 0), TextSize = 13, Font = Enum.Font.Gotham, TextXAlignment = Enum.TextXAlignment.Left,
    		PlaceholderText = "Search...", Text = "", TextColor3 = theme.colors.text, PlaceholderColor3 = theme.colors.textMuted,
    	})
    	Util.Roundify(search, 6, theme.colors.border, 0.8); Util.Padding(search, 6)
    	search.Parent = header
    	local clearBtn = Util.Create("TextButton", { Text = "Clear", AutoButtonColor=false, BackgroundColor3=theme.colors.inputBg, BorderSizePixel=0, Size = UDim2.new(0, 52, 1, 0), Position = UDim2.new(1, -52, 0, 0) })
    	Util.Roundify(clearBtn, 6, theme.colors.border, 0.8)
    	clearBtn.Parent = header
    
    	local list = Util.Create("ScrollingFrame", {
    		BackgroundTransparency = 1, BorderSizePixel = 0, Size = UDim2.new(1, 0, 1, -28), Position = UDim2.new(0, 0, 0, 28),
    		ScrollBarThickness = 6, CanvasSize = UDim2.new(0,0,0,0), ScrollBarImageTransparency = 0.5,
    	})
    	list.Parent = root
    	local uiList = Util.VList(list, 4, Enum.HorizontalAlignment.Left)
    	self:_trackConn(uiList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    		list.CanvasSize = UDim2.new(0,0,0, uiList.AbsoluteContentSize.Y + 8)
    		list.CanvasPosition = Vector2.new(0, math.max(0, uiList.AbsoluteContentSize.Y - list.AbsoluteWindowSize.Y))
    	end))
    
    	local entries = {}
    
    	local function enforceCap()
    		while #entries > self.MaxEntries do
    			local oldest = table.remove(entries, 1)
    			if oldest and oldest.Parent then oldest:Destroy() end
    		end
    	end
    
    	function rebuild()
    		list:ClearAllChildren()
    		entries = {}
    		for _, e in ipairs(LogManager.list({ search = self.Search })) do
    			local msg = e.message or ""
    			if self.Search ~= "" and not string.find(string.lower(msg), string.lower(self.Search), 1, true) then
    				-- skip
    			else
    				if self.Levels[e.level] then
    					local row = Util.Create("TextLabel", {
    						BackgroundTransparency = 1,
    						Size = UDim2.new(1, -6, 0, 18),
    						TextXAlignment = Enum.TextXAlignment.Left,
    						TextYAlignment = Enum.TextYAlignment.Center,
    						TextSize = 13,
    						Font = Enum.Font.Code,
    						Text = string.format("[%s] %s", string.upper(e.level), msg),
    						TextColor3 = levelColor(e.level, Theme.current()),
    					})
    					row.Parent = list
    					entries[#entries+1] = row
    					Animator.tween(row, Animator.Durations.Fast, { TextTransparency = 0 })
    					enforceCap()
    				end
    			end
    		end
    	end
    
    	self:_trackConn(search:GetPropertyChangedSignal("Text"):Connect(function()
    		self.Search = search.Text or ""
    		rebuild()
    	end))
    
    	self:_trackConn(clearBtn.MouseButton1Click:Connect(function()
    		LogManager.clear()
    	end))
    
    	self:_trackConn(LogManager.added:Connect(function(e)
    		-- Add new entries only if pass filters and search
    		local msg = e.message or ""
    		if self.Search ~= "" and not string.find(string.lower(msg), string.lower(self.Search), 1, true) then return end
    		if not self.Levels[e.level] then return end
    		local row = Util.Create("TextLabel", {
    			BackgroundTransparency = 1, Size = UDim2.new(1, -6, 0, 18), TextXAlignment = Enum.TextXAlignment.Left, TextYAlignment = Enum.TextYAlignment.Center,
    			TextSize = 13, Font = Enum.Font.Code, Text = string.format("[%s] %s", string.upper(e.level), msg), TextColor3 = levelColor(e.level, Theme.current()),
    		})
    		row.Parent = list
    		entries[#entries+1] = row
    		Animator.tween(row, Animator.Durations.Fast, { TextTransparency = 0 })
    		enforceCap()
    	end))
    	self:_trackConn(LogManager.cleared:Connect(function()
    		rebuild()
    	end))
    
    	self:_trackConn(ErrorHandler.event:Connect(function(level, msg)
    		LogManager.append(level, msg)
    	end))
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		local s = root:FindFirstChildOfClass("UIStroke"); if s then s.Color = newTheme.colors.border end
    		search.BackgroundColor3 = newTheme.colors.inputBg
    		search.TextColor3 = newTheme.colors.text
    		search.PlaceholderColor3 = newTheme.colors.textMuted
    		-- Rebuild to recolor level text
    		rebuild()
    	end))
    
    	rebuild()
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return Console
    
  end
  __modules["components/ProgressBar"] = function(require, script)
    -- ProgressBar component
    -- Props:
    -- Value (number 0..1)
    -- Label (string) optional
    -- Size (UDim2) default (220, 12)
    -- Parent (Instance) optional
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local ProgressBar = Base.extend({})
    
    function ProgressBar.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, ProgressBar)
    	self.Value = math.clamp(tonumber(props.Value) or 0, 0, 1)
    
    	local theme = Theme.current()
    
    	local root = Util.Create("Frame", {
    		Name = "MintProgressBar",
    		BackgroundTransparency = 1,
    		Size = props.Size or UDim2.fromOffset(220, 16),
    	})
    	self:_own(root)
    
    	local track = Util.Create("Frame", {
    		BackgroundColor3 = theme.colors.border,
    		BorderSizePixel = 0,
    		Size = UDim2.new(1, 0, 0, 8),
    		Position = UDim2.new(0, 0, 0.5, -4),
    	})
    	Util.Roundify(track, 4)
    	track.Parent = root
    
    	local fill = Util.Create("Frame", {
    		BackgroundColor3 = theme.colors.primary,
    		BorderSizePixel = 0,
    		Size = UDim2.new(self.Value, 0, 1, 0),
    	})
    	Util.Roundify(fill, 4)
    	fill.Parent = track
    
    	local label
    	if props.Label then
    		label = Util.Create("TextLabel", {
    			BackgroundTransparency = 1,
    			Size = UDim2.new(1, 0, 0, 14),
    			Position = UDim2.new(0, 0, 0, -16),
    			Text = tostring(props.Label),
    			TextColor3 = theme.colors.text,
    			Font = Enum.Font.Gotham,
    			TextSize = 12,
    			TextXAlignment = Enum.TextXAlignment.Left,
    		})
    		label.Parent = root
    	end
    
    	function self:SetValue(v)
    		self.Value = math.clamp(tonumber(v) or 0, 0, 1)
    		Animator.tween(fill, Animator.Durations.Fast, { Size = UDim2.new(self.Value, 0, 1, 0) })
    	end
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		track.BackgroundColor3 = newTheme.colors.border
    		fill.BackgroundColor3 = newTheme.colors.primary
    		if label then label.TextColor3 = newTheme.colors.text end
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return ProgressBar
    
  end
  __modules["core/Animator"] = function(require, script)
    -- Animator: centralizes tween timings and micro-interactions
    local TweenService = game:GetService("TweenService")
    
    local Animator = {}
    
    Animator.Durations = {
    	Fast = 0.12,
    	Normal = 0.2,
    	Slow = 0.35,
    }
    
    Animator.Easings = {
    	Enter = Enum.EasingStyle.Quad,
    	Exit = Enum.EasingStyle.Quad,
    	Hover = Enum.EasingStyle.Sine,
    }
    
    function Animator.tween(inst, duration, properties, easingStyle, easingDirection)
    	local info = TweenInfo.new(duration or Animator.Durations.Normal, easingStyle or Animator.Easings.Enter, easingDirection or Enum.EasingDirection.Out)
    	local tween = TweenService:Create(inst, info, properties)
    	tween:Play()
    	return tween
    end
    
    -- Hover effect: returns connections and a cleanup function
    function Animator.bindHover(buttonLikeInst, lightenColor3)
    	local original
    	local enterConn = buttonLikeInst.MouseEnter:Connect(function()
    		if buttonLikeInst:IsA("TextButton") or buttonLikeInst:IsA("ImageButton") or buttonLikeInst:IsA("Frame") then
    			original = buttonLikeInst.BackgroundColor3
    			local c = original
    			if lightenColor3 then c = lightenColor3 end
    			Animator.tween(buttonLikeInst, Animator.Durations.Fast, { BackgroundColor3 = c })
    		end
    	end)
    	local leaveConn = buttonLikeInst.MouseLeave:Connect(function()
    		if original then
    			Animator.tween(buttonLikeInst, Animator.Durations.Fast, { BackgroundColor3 = original })
    		end
    	end)
    	return function()
    		if enterConn.Connected then enterConn:Disconnect() end
    		if leaveConn.Connected then leaveConn:Disconnect() end
    	end
    end
    
    function Animator.pressScale(inst)
    	local down = inst.MouseButton1Down:Connect(function()
    		Animator.tween(inst, Animator.Durations.Fast, { Size = inst.Size - UDim2.fromOffset(2, 2) })
    	end)
    	local up = inst.MouseButton1Up:Connect(function()
    		Animator.tween(inst, Animator.Durations.Fast, { Size = inst.Size + UDim2.fromOffset(2, 2) })
    	end)
    	return function()
    		if down.Connected then down:Disconnect() end
    		if up.Connected then up:Disconnect() end
    	end
    end
    
    return Animator
    
  end
  __modules["components/Button"] = function(require, script)
    -- Button component
    -- Props:
    -- Text (string)
    -- Icon (string asset id) optional
    -- Action (string) optional; if set, click invokes Registry.invoke(Action)
    -- OnClick (function) optional
    -- Style ("Primary"|"Secondary"|"Ghost") default Primary
    -- Size (UDim2) optional; default {0,160},{0,36}
    -- Parent (Instance) optional
    -- Return: component table with Instance (TextButton)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Registry = require(script.Parent.Parent.core.Registry)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Button = Base.extend({})
    
    local function styleColors(theme, style)
    	if style == "Secondary" then
    		return theme.colors.surface, theme.colors.text
    	elseif style == "Ghost" then
    		return Color3.fromRGB(0,0,0), theme.colors.text -- true transparent background via AutoButtonColor off
    	else
    		return theme.colors.primary, Color3.fromRGB(255,255,255)
    	end
    end
    
    function Button.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Button)
    	self.Props = props
    
    	local theme = Theme.current()
    	local bgColor, textColor = styleColors(theme, props.Style)
    
    	local btn = Util.Create("TextButton", {
    		Name = "MintButton",
    		Size = props.Size or UDim2.fromOffset(160, 36),
    		AutoButtonColor = false,
    		BackgroundTransparency = (props.Style == "Ghost") and 1 or 0,
    		BackgroundColor3 = bgColor,
    		BorderSizePixel = 0,
    		Text = tostring(props.Text or "Button"),
    		TextColor3 = textColor,
    		Font = Enum.Font.GothamSemibold,
    		TextSize = 14,
    	})
    	Util.Roundify(btn, 8, theme.colors.border, 0.6)
    	Util.Padding(btn, 6)
    	self:_own(btn)
    
    	-- Hover/press micro-interactions
    	if props.Style ~= "Ghost" then
    		local unhover = Animator.bindHover(btn, theme.colors.primaryVariant)
    		self:_trackCleanup(unhover)
    	end
    	local unpress = Animator.pressScale(btn)
    	self:_trackCleanup(unpress)
    
    	-- Icon optional (left)
    	if props.Icon then
    		local image = Util.Create("ImageLabel", {
    			Name = "Icon",
    			BackgroundTransparency = 1,
    			Size = UDim2.fromOffset(16, 16),
    			Image = props.Icon,
    			ImageColor3 = textColor,
    			ZIndex = btn.ZIndex + 1,
    		})
    		image.Parent = btn
    		-- shift text with a UIListLayout
    		local container = Util.Create("Frame", {
    			Name = "Inner",
    			BackgroundTransparency = 1,
    			Size = UDim2.fromScale(1,1),
    		})
    		container.Parent = btn
    		local layout = Util.HList(container, 6, Enum.VerticalAlignment.Center)
    		image.Parent = container
    		local textLabel = Util.Create("TextLabel", {
    			BackgroundTransparency = 1,
    			Size = UDim2.new(1, -24, 1, 0),
    			Text = btn.Text,
    			TextColor3 = textColor,
    			Font = btn.Font,
    			TextSize = btn.TextSize,
    		})
    		textLabel.Parent = container
    		btn.TextTransparency = 1
    	end
    
    	-- Theme reaction
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		local bg, txt = styleColors(newTheme, props.Style)
    		btn.BackgroundColor3 = (props.Style == "Ghost") and btn.BackgroundColor3 or bg
    		btn.TextColor3 = txt
    		local icon = btn:FindFirstChild("Icon", true)
    		if icon and icon:IsA("ImageLabel") then
    			icon.ImageColor3 = txt
    		end
    	end))
    
    	self:_trackConn(btn.MouseButton1Click:Connect(function()
    		if props.OnClick then
    			local ok, err = pcall(props.OnClick)
    			if not ok then warn("Mint Button OnClick error: " .. tostring(err)) end
    		end
    		if props.Action then
    			Registry.invoke(props.Action)
    		end
    	end))
    
    	self.Instance = btn
    	if props.Parent then btn.Parent = props.Parent end
    	return self
    end
    
    return Button
    
  end
  __modules["core/Util"] = function(require, script)
    -- Utility helpers for MinT UI
    local TweenService = game:GetService("TweenService")
    
    local Util = {}
    
    -- Shallow assign/merge: later tables override earlier ones
    function Util.Assign(...)
    	local result = {}
    	for i = 1, select('#', ...) do
    		local src = select(i, ...)
    		if type(src) == "table" then
    			for k, v in pairs(src) do
    				result[k] = v
    			end
    		end
    	end
    	return result
    end
    
    -- Create Instance helper
    -- Usage: Util.Create("Frame", propsTable, childrenArray)
    function Util.Create(className, props, children)
    	local inst = Instance.new(className)
    	if props then
    		for k, v in pairs(props) do
    			pcall(function()
    				inst[k] = v
    			end)
    		end
    	end
    	if children then
    		for _, child in ipairs(children) do
    			if typeof(child) == "Instance" then
    				child.Parent = inst
    			end
    		end
    	end
    	return inst
    end
    
    -- Tween a single instance property safely
    function Util.Tween(inst, tweenInfo, goal)
    	local ok, tween = pcall(function()
    		return TweenService:Create(inst, tweenInfo, goal)
    	end)
    	if ok and tween then
    		tween:Play()
    		return tween
    	end
    	return nil
    end
    
    -- Apply UICorner and UIStroke to an Instance
    function Util.Roundify(inst, radius, strokeColor, strokeTransparency)
    	radius = radius or 8
    	strokeTransparency = strokeTransparency or 0.5
    	local corner = Util.Create("UICorner", { CornerRadius = UDim.new(0, radius) })
    	corner.Parent = inst
    	local stroke = Util.Create("UIStroke", {
    		ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
    		Color = strokeColor or Color3.fromRGB(255, 255, 255),
    		Transparency = strokeTransparency,
    		Thickness = 1,
    	})
    	stroke.Parent = inst
    	return corner, stroke
    end
    
    -- Apply padding to Frames
    function Util.Padding(parent, padding)
    	padding = padding or 8
    	local pad = Util.Create("UIPadding", {
    		PaddingTop = UDim.new(0, padding),
    		PaddingBottom = UDim.new(0, padding),
    		PaddingLeft = UDim.new(0, padding),
    		PaddingRight = UDim.new(0, padding),
    	})
    	pad.Parent = parent
    	return pad
    end
    
    -- Safe connect helper that returns a disconnect function
    function Util.Connect(signal, fn)
    	local conn = signal:Connect(fn)
    	return function()
    		if conn and conn.Connected then conn:Disconnect() end
    	end
    end
    
    -- Clamp helper
    function Util.Clamp(n, min, max)
    	if n < min then return min end
    	if n > max then return max end
    	return n
    end
    
    -- Lerp
    function Util.Lerp(a, b, t)
    	return a + (b - a) * t
    end
    
    -- UI list layout helper
    function Util.VList(parent, padding, align)
    	local layout = Util.Create("UIListLayout", {
    		Padding = UDim.new(0, padding or 8),
    		FillDirection = Enum.FillDirection.Vertical,
    		HorizontalAlignment = align or Enum.HorizontalAlignment.Center,
    		SortOrder = Enum.SortOrder.LayoutOrder,
    	})
    	layout.Parent = parent
    	return layout
    end
    
    function Util.HList(parent, padding, align)
    	local layout = Util.Create("UIListLayout", {
    		Padding = UDim.new(0, padding or 8),
    		FillDirection = Enum.FillDirection.Horizontal,
    		VerticalAlignment = align or Enum.VerticalAlignment.Center,
    		SortOrder = Enum.SortOrder.LayoutOrder,
    	})
    	layout.Parent = parent
    	return layout
    end
    
    return Util
    
  end
  __modules["components/Tabs"] = function(require, script)
    -- Tabs component: top tab bar with content container
    -- Props:
    -- Tabs: array of { id=string, title=string, content=Instance | function(parent) -> Instance }
    -- OnChanged(id)
    -- Size (UDim2)
    -- Parent (Instance)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Tabs = Base.extend({})
    
    function Tabs.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Tabs)
    	self.OnChanged = props.OnChanged
    	self._tabs = {}
    	self._selected = nil
    
    	local theme = Theme.current()
    
    	local root = Util.Create("Frame", {
    		Name = "MintTabs",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = props.Size or UDim2.fromOffset(520, 300),
    		ClipsDescendants = true,
    	})
    	self:_own(root)
    	Util.Roundify(root, 8, theme.colors.border, 0.9)
    	Util.Padding(root, 8)
    
    	local header = Util.Create("Frame", {
    		Name = "Header",
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 0, 28),
    	})
    	header.Parent = root
    	local tabList = Util.HList(header, 6, Enum.VerticalAlignment.Center)
    	local content = Util.Create("Frame", {
    		Name = "Content",
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 1, -32),
    		Position = UDim2.new(0, 0, 0, 32),
    	})
    	content.Parent = root
    
    	local function makeTabButton(tab)
    		local btn = Util.Create("TextButton", {
    			Name = "Tab_"..tab.id,
    			AutoButtonColor = false,
    			BackgroundColor3 = theme.colors.inputBg,
    			BorderSizePixel = 0,
    			Text = tab.title or tab.id,
    			TextColor3 = theme.colors.text,
    			Font = Enum.Font.Gotham,
    			TextSize = 14,
    			Size = UDim2.fromOffset(100, 28),
    		})
    		Util.Roundify(btn, 6, theme.colors.border, 0.8)
    		btn.Parent = header
    		return btn
    	end
    
    	local function selectTab(id)
    		if self._selected == id then return end
    		self._selected = id
    		-- update buttons
    		for _, t in pairs(self._tabs) do
    			local active = (t.id == id)
    			local target = active and theme.colors.primary or theme.colors.inputBg
    			local textColor = active and Color3.new(1,1,1) or theme.colors.text
    			Animator.tween(t.button, Animator.Durations.Fast, { BackgroundColor3 = target, TextColor3 = textColor })
    			if t.view then t.view.Visible = active end
    		end
    		if self.OnChanged then
    			local ok, err = pcall(self.OnChanged, id)
    			if not ok then warn(err) end
    		end
    	end
    
    	function self:AddTab(tab)
    		-- tab: { id, title, content }
    		assert(tab and tab.id, "Tab requires id")
    		local button = makeTabButton(tab)
    		local view
    		if typeof(tab.content) == "Instance" then
    			view = tab.content
    		elseif type(tab.content) == "function" then
    			view = tab.content(content)
    		else
    			view = Util.Create("Frame", { BackgroundTransparency = 1, Size = UDim2.fromScale(1,1) })
    		end
    		view.Visible = false
    		view.Size = UDim2.fromScale(1,1)
    		view.Parent = content
    
    		local rec = { id = tab.id, button = button, view = view }
    		self._tabs[tab.id] = rec
    
    		self:_trackConn(button.MouseButton1Click:Connect(function()
    			selectTab(tab.id)
    		end))
    
    		if not self._selected then
    			selectTab(tab.id)
    		end
    		return rec
    	end
    
    	-- Seed tabs
    	for _, t in ipairs(props.Tabs or {}) do self:AddTab(t) end
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		local s = root:FindFirstChildOfClass("UIStroke"); if s then s.Color = newTheme.colors.border end
    		for _, t in pairs(self._tabs) do
    			local active = (t.id == self._selected)
    			t.button.TextColor3 = active and Color3.new(1,1,1) or newTheme.colors.text
    			t.button.BackgroundColor3 = active and newTheme.colors.primary or newTheme.colors.inputBg
    			local st = t.button:FindFirstChildOfClass("UIStroke"); if st then st.Color = newTheme.colors.border end
    		end
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return Tabs
    
  end
  __modules["components/Dropdown"] = function(require, script)
    -- Dropdown component
    -- Props:
    -- Items (array) - either array of strings or array of { text=string, value=any }
    -- Placeholder (string)
    -- SelectedValue (any)
    -- OnChanged (function:value, item)
    -- Action (string) optional; Registry.invoke(Action, value)
    -- Size (UDim2) default (220, 32)
    -- MaxMenuHeight (number) default 160
    -- Parent (Instance) optional
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Registry = require(script.Parent.Parent.core.Registry)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Dropdown = Base.extend({})
    
    local function normalizeItems(items)
    	local out = {}
    	for i, it in ipairs(items or {}) do
    		if type(it) == "string" then
    			out[#out+1] = { text = it, value = it }
    		elseif type(it) == "table" then
    			out[#out+1] = { text = tostring(it.text or it.value or ("Item "..i)), value = it.value ~= nil and it.value or it.text }
    		end
    	end
    	return out
    end
    
    function Dropdown.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Dropdown)
    	self.Items = normalizeItems(props.Items or {})
    	self.SelectedValue = props.SelectedValue
    	self.OnChanged = props.OnChanged
    	self.Action = props.Action
    	self._overlay = nil
    
    	local theme = Theme.current()
    
    	local root = Util.Create("Frame", {
    		Name = "MintDropdown",
    		BackgroundTransparency = 1,
    		ClipsDescendants = false,
    		Size = props.Size or UDim2.fromOffset(220, 32),
    	})
    	self:_own(root)
    
    	local button = Util.Create("TextButton", {
    		Name = "Button",
    		AutoButtonColor = false,
    		BackgroundColor3 = theme.colors.inputBg,
    		BorderSizePixel = 0,
    		Size = UDim2.new(1, 0, 1, 0),
    		Text = "",
    	})
    	Util.Roundify(button, 6, theme.colors.border, 0.7)
    	Util.Padding(button, 8)
    	button.Parent = root
    
    	local label = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, -20, 1, 0),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		Text = props.Placeholder or "Select...",
    		TextColor3 = theme.colors.textMuted,
    		Font = Enum.Font.Gotham,
    		TextSize = 14,
    	})
    	label.Parent = button
    
    	local chevron = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.fromOffset(16, 16),
    		Position = UDim2.new(1, -16, 0.5, -8),
    		Text = "▼",
    		TextColor3 = theme.colors.textMuted,
    		Font = Enum.Font.GothamBold,
    		TextSize = 12,
    	})
    	chevron.Parent = button
    
    	local menu = Util.Create("Frame", {
    		Name = "Menu",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Visible = false,
    		Position = UDim2.new(0, 0, 1, 4),
    		Size = UDim2.new(1, 0, 0, math.min(props.MaxMenuHeight or 160, 160)),
    		ClipsDescendants = true,
    		ZIndex = 100,
    	})
    	Util.Roundify(menu, 6, theme.colors.border, 0.7)
    	Util.Padding(menu, 4)
    	menu.Parent = root
    	self:_own(menu)
    
    	local list = Util.Create("ScrollingFrame", {
    		BackgroundTransparency = 1,
    		BorderSizePixel = 0,
    		ScrollBarThickness = 6,
    		ScrollBarImageTransparency = 0.5,
    		CanvasSize = UDim2.new(0,0,0,0),
    		Size = UDim2.new(1, -2, 1, -2),
    		ZIndex = 101,
    	})
    	local uiList = Util.VList(list, 4, Enum.HorizontalAlignment.Left)
    	self:_trackConn(uiList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    		list.CanvasSize = UDim2.new(0,0,0, uiList.AbsoluteContentSize.Y + 8)
    	end))
    	list.Parent = menu
    
    	local function rebuildMenu()
    		list:ClearAllChildren()
    		for _, item in ipairs(self.Items) do
    			local opt = Util.Create("TextButton", {
    				AutoButtonColor = false,
    				BackgroundColor3 = theme.colors.surface,
    				BorderSizePixel = 0,
    				Size = UDim2.new(1, -4, 0, 28),
    				TextXAlignment = Enum.TextXAlignment.Left,
    				Text = "  " .. tostring(item.text),
    				TextColor3 = theme.colors.text,
    				Font = Enum.Font.Gotham,
    				TextSize = 14,
    				ZIndex = 102,
    			})
    			Util.Roundify(opt, 4, theme.colors.border, 1)
    			opt.Parent = list
    			self:_trackConn(opt.MouseEnter:Connect(function()
    				Animator.tween(opt, Animator.Durations.Fast, { BackgroundColor3 = theme.colors.inputBg })
    			end))
    			self:_trackConn(opt.MouseLeave:Connect(function()
    				Animator.tween(opt, Animator.Durations.Fast, { BackgroundColor3 = theme.colors.surface })
    			end))
    			self:_trackConn(opt.MouseButton1Click:Connect(function()
    				self:SetSelected(item.value, true)
    			end))
    		end
    	end
    
    	local open = false
    
    	local function destroyOverlay()
    		if self._overlay then
    			self._overlay:Destroy()
    			self._overlay = nil
    		end
    	end
    
    	local function setOpen(v)
    		if v == open then return end
    		open = v
    		menu.Visible = v
    		if v then
    			-- overlay to capture outside clicks
    			local screenGui = root:FindFirstAncestorWhichIsA("ScreenGui")
    			if screenGui then
    				local overlay = Instance.new("TextButton")
    				overlay.Name = "Mint_Dropdown_Overlay"
    				overlay.AutoButtonColor = false
    				overlay.BackgroundTransparency = 1
    				overlay.Text = ""
    				overlay.ZIndex = menu.ZIndex - 1
    				overlay.Size = UDim2.fromScale(1,1)
    				overlay.Parent = screenGui
    				self:_trackConn(overlay.MouseButton1Click:Connect(function()
    					setOpen(false)
    				end))
    				self._overlay = overlay
    				self:_own(overlay)
    			end
    			menu.Size = UDim2.new(1, 0, 0, 0)
    			Animator.tween(menu, Animator.Durations.Normal, { Size = UDim2.new(1, 0, 0, math.min(props.MaxMenuHeight or 160, 160)) })
    		else
    			Animator.tween(menu, Animator.Durations.Fast, { Size = UDim2.new(1, 0, 0, 0) })
    			destroyOverlay()
    		end
    	end
    
    	self:_trackConn(button.MouseButton1Click:Connect(function()
    		setOpen(not open)
    	end))
    
    	function self:SetItems(items)
    		self.Items = normalizeItems(items)
    		rebuildMenu()
    	end
    
    	function self:SetSelected(value, fire)
    		self.SelectedValue = value
    		local found
    		for _, item in ipairs(self.Items) do
    			if item.value == value then found = item break end
    		end
    		if found then
    			label.Text = tostring(found.text)
    			label.TextColor3 = theme.colors.text
    			chevron.TextColor3 = theme.colors.textMuted
    		else
    			label.Text = props.Placeholder or "Select..."
    			label.TextColor3 = theme.colors.textMuted
    		end
    		setOpen(false)
    		if fire then
    			if self.OnChanged then
    				local ok, err = pcall(self.OnChanged, self.SelectedValue, found)
    				if not ok then warn(err) end
    			end
    			if self.Action then
    				Registry.invoke(self.Action, self.SelectedValue)
    			end
    		end
    	end
    
    	rebuildMenu()
    	if self.SelectedValue ~= nil then
    		self:SetSelected(self.SelectedValue, false)
    	end
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		button.BackgroundColor3 = newTheme.colors.inputBg
    		local stroke = button:FindFirstChildOfClass("UIStroke")
    		if stroke then stroke.Color = newTheme.colors.border end
    		label.TextColor3 = (self.SelectedValue ~= nil) and newTheme.colors.text or newTheme.colors.textMuted
    		chevron.TextColor3 = newTheme.colors.textMuted
    		menu.BackgroundColor3 = newTheme.colors.surface
    		local s = menu:FindFirstChildOfClass("UIStroke"); if s then s.Color = newTheme.colors.border end
    		rebuildMenu()
    		if self.SelectedValue ~= nil then
    			self:SetSelected(self.SelectedValue, false)
    		end
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return Dropdown
    
  end
  __modules["core/Responsive"] = function(require, script)
    -- Responsive: attaches a UIScale to a ScreenGui that updates with viewport size
    -- Default strategy: scale relative to 1080p height with clamping
    local Responsive = {}
    
    local DEFAULTS = {
    	BaseHeight = 1080,
    	MinScale = 0.75,
    	MaxScale = 1.25,
    }
    
    local function getViewportSize()
    	local camera = workspace.CurrentCamera
    	if camera then
    		return camera.ViewportSize
    	end
    	return Vector2.new(1920, 1080)
    end
    
    local function computeScale(opts)
    	local vp = getViewportSize()
    	local scale = vp.Y / (opts.BaseHeight or DEFAULTS.BaseHeight)
    	if opts.MinScale then scale = math.max(scale, opts.MinScale) end
    	if opts.MaxScale then scale = math.min(scale, opts.MaxScale) end
    	return scale
    end
    
    function Responsive.Attach(screenGui, opts)
    	assert(screenGui and screenGui:IsA("ScreenGui"), "Responsive.Attach requires a ScreenGui")
    	opts = setmetatable(opts or {}, { __index = DEFAULTS })
    	local scaleInst = Instance.new("UIScale")
    	scaleInst.Name = "Mint_UIScale"
    	scaleInst.Parent = screenGui
    
    	local function update()
    		local s = computeScale(opts)
    		scaleInst.Scale = s
    	end
    
    	update()
    
    	local conns = {}
    	local camera = workspace.CurrentCamera
    	if camera then
    		conns[#conns+1] = camera:GetPropertyChangedSignal("ViewportSize"):Connect(update)
    	end
    	conns[#conns+1] = screenGui.AncestryChanged:Connect(function()
    		if not screenGui.Parent then
    			for _, c in ipairs(conns) do if c.Connected then c:Disconnect() end end
    		end
    	end)
    
    	return scaleInst, function()
    		for _, c in ipairs(conns) do if c.Connected then c:Disconnect() end end
    		if scaleInst then scaleInst:Destroy() end
    	end
    end
    
    return Responsive
    
  end
  __modules["components/Label"] = function(require, script)
    -- Label component: theme-aware text display
    -- Props:
    -- Text (string)
    -- Size (UDim2) optional
    -- TextSize (number) optional
    -- Bold (boolean) optional
    -- Parent (Instance) optional
    
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Util = require(script.Parent.Parent.core.Util)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Label = Base.extend({})
    
    function Label.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Label)
    	self.Props = props
    
    	local theme = Theme.current()
    	local label = Util.Create("TextLabel", {
    		Name = "MintLabel",
    		BackgroundTransparency = 1,
    		Size = props.Size or UDim2.fromOffset(160, 24),
    		Text = tostring(props.Text or "Label"),
    		TextColor3 = theme.colors.text,
    		Font = props.Bold and Enum.Font.GothamBold or Enum.Font.Gotham,
    		TextSize = props.TextSize or 14,
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    	})
    	self:_own(label)
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		label.TextColor3 = newTheme.colors.text
    	end))
    
    	self.Instance = label
    	if props.Parent then label.Parent = props.Parent end
    	return self
    end
    
    return Label
    
  end
  __modules["components/Slider"] = function(require, script)
    -- Slider component
    -- Props:
    -- Label (string)
    -- Min (number) default 0
    -- Max (number) default 100
    -- Step (number) optional; if set, snaps value
    -- Value (number) initial value
    -- OnChanged (function:number)
    -- Action (string) optional; Registry.invoke(Action, value)
    -- Size (UDim2) default (200, 40)
    -- Parent (Instance) optional
    
    local UserInputService = game:GetService("UserInputService")
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Registry = require(script.Parent.Parent.core.Registry)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local Slider = Base.extend({})
    
    local function clamp(v, min, max)
    	if v < min then return min end
    	if v > max then return max end
    	return v
    end
    
    local function snap(v, step)
    	if not step or step <= 0 then return v end
    	return math.floor((v / step) + 0.5) * step
    end
    
    function Slider.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, Slider)
    
    	self.Min = type(props.Min) == "number" and props.Min or 0
    	self.Max = type(props.Max) == "number" and props.Max or 100
    	self.Step = type(props.Step) == "number" and props.Step or nil
    	self.Value = type(props.Value) == "number" and props.Value or self.Min
    	self.OnChanged = props.OnChanged
    	self.Action = props.Action
    
    	local theme = Theme.current()
    
    	local root = Util.Create("Frame", {
    		Name = "MintSlider",
    		BackgroundTransparency = 1,
    		Size = props.Size or UDim2.fromOffset(220, 40),
    	})
    	self:_own(root)
    
    	local vlist = Util.VList(root, 6)
    	vlist.HorizontalAlignment = Enum.HorizontalAlignment.Left
    
    	local label = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 0, 16),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		Text = tostring(props.Label or "Slider"),
    		TextColor3 = theme.colors.text,
    		Font = Enum.Font.Gotham,
    		TextSize = 13,
    	})
    	label.Parent = root
    
    	local track = Util.Create("Frame", {
    		Name = "Track",
    		BackgroundColor3 = theme.colors.border,
    		BorderSizePixel = 0,
    		Size = UDim2.new(1, 0, 0, 6),
    	})
    	Util.Roundify(track, 3)
    	track.Parent = root
    
    	local fill = Util.Create("Frame", {
    		Name = "Fill",
    		BackgroundColor3 = theme.colors.primary,
    		BorderSizePixel = 0,
    		Size = UDim2.new(0, 0, 1, 0),
    	})
    	Util.Roundify(fill, 3)
    	fill.Parent = track
    
    	local knob = Util.Create("Frame", {
    		Name = "Knob",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = UDim2.fromOffset(14, 14),
    		Position = UDim2.fromOffset(0, -4),
    	})
    	Util.Roundify(knob, 7, theme.colors.primary, 0)
    	knob.Parent = fill
    
    	local dragging = false
    	local function setValueFromX(x)
    		local absPos = track.AbsolutePosition.X
    		local width = track.AbsoluteSize.X
    		local alpha = clamp((x - absPos) / math.max(1, width), 0, 1)
    		local newVal = self.Min + (self.Max - self.Min) * alpha
    		newVal = snap(newVal, self.Step)
    		newVal = clamp(newVal, self.Min, self.Max)
    		self:SetValue(newVal, true)
    	end
    
    	local function refresh(animate)
    		local alpha = (self.Value - self.Min) / math.max(1e-6, (self.Max - self.Min))
    		alpha = clamp(alpha, 0, 1)
    		local goalFill = { Size = UDim2.new(alpha, 0, 1, 0) }
    		if animate then
    			Animator.tween(fill, Animator.Durations.Fast, goalFill)
    		else
    			fill.Size = goalFill.Size
    		end
    	end
    
    	function self:SetValue(v, fire)
    		v = clamp(v, self.Min, self.Max)
    		if self.Step then v = snap(v, self.Step) end
    		self.Value = v
    		refresh(true)
    		if fire then
    			if self.OnChanged then
    				local ok, err = pcall(self.OnChanged, self.Value)
    				if not ok then warn(err) end
    			end
    			if self.Action then
    				Registry.invoke(self.Action, self.Value)
    			end
    		end
    	end
    
    	-- Input handling
    	self:_trackConn(track.InputBegan:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
    			dragging = true
    			setValueFromX(UserInputService:GetMouseLocation().X)
    		end
    	end))
    	self:_trackConn(track.InputEnded:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
    			dragging = false
    		end
    	end))
    	self:_trackConn(UserInputService.InputChanged:Connect(function(input)
    		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
    			setValueFromX(UserInputService:GetMouseLocation().X)
    		end
    	end))
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		label.TextColor3 = newTheme.colors.text
    		track.BackgroundColor3 = newTheme.colors.border
    		fill.BackgroundColor3 = newTheme.colors.primary
    	end))
    
    	refresh(false)
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return Slider
    
  end
  __modules["core/Queue"] = function(require, script)
    -- Queue: simple queue manager for script tasks
    -- API:
    -- local q = Queue.new()
    -- local id = q:enqueue({ name = "Script A", payload = any })
    -- q:start(id) / q:pause(id) / q:stop(id) / q:remove(id)
    -- Events: q.changed (operation, item)
    
    local HttpService = game:GetService("HttpService")
    local Event = require(script.Parent.Event)
    
    local Queue = {}
    Queue.__index = Queue
    
    function Queue.new()
    	local self = setmetatable({}, Queue)
    	self.items = {}
    	self.order = {}
    	self.changed = Event.new()
    	return self
    end
    
    local function findIndex(t, id)
    	for i, v in ipairs(t) do if v == id then return i end end
    	return nil
    end
    
    function Queue:_emit(op, item)
    	self.changed:Fire(op, item)
    end
    
    function Queue:enqueue(meta)
    	local id = HttpService:GenerateGUID(false)
    	local item = {
    		id = id,
    		name = (meta and meta.name) or ("Item " .. tostring(#self.order+1)),
    		status = "queued", -- queued | running | paused | done | failed | stopped
    		progress = 0,
    		payload = meta and meta.payload,
    		result = nil,
    	}
    	self.items[id] = item
    	table.insert(self.order, id)
    	self:_emit("enqueue", item)
    	return id, item
    end
    
    function Queue:get(id)
    	return self.items[id]
    end
    
    function Queue:list()
    	local out = {}
    	for _, id in ipairs(self.order) do out[#out+1] = self.items[id] end
    	return out
    end
    
    function Queue:update(id, patch)
    	local item = self.items[id]
    	if not item then return false end
    	for k, v in pairs(patch) do item[k] = v end
    	self:_emit("update", item)
    	return true
    end
    
    function Queue:start(id)
    	return self:update(id, { status = "running" })
    end
    
    function Queue:pause(id)
    	return self:update(id, { status = "paused" })
    end
    
    function Queue:stop(id)
    	return self:update(id, { status = "stopped" })
    end
    
    function Queue:complete(id, ok, result)
    	return self:update(id, { status = ok and "done" or "failed", result = result, progress = 1 })
    end
    
    function Queue:remove(id)
    	local idx = findIndex(self.order, id)
    	if not idx then return false end
    	table.remove(self.order, idx)
    	local item = self.items[id]
    	self.items[id] = nil
    	self:_emit("remove", item)
    	return true
    end
    
    function Queue:clear()
    	self.items = {}
    	self.order = {}
    	self:_emit("clear")
    end
    
    return Queue
    
  end
  __modules["components/CodeEditor"] = function(require, script)
    -- CodeEditor component (basic multi-line editor with simple Lua highlighting, line numbers, and scrolling)
    -- Props:
    -- Text (string)
    -- OnChanged (function:string)
    -- OnValidate (function:string -> ok, errInfo?) optional; defaults to Validator.basicSyntax
    -- Size (UDim2) default (480, 260)
    -- AutoSaveKey (string) optional to auto-save via Storage
    -- Parent (Instance) optional
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Storage = require(script.Parent.Parent.core.Storage)
    local Validator = require(script.Parent.Parent.core.Validator)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local CodeEditor = Base.extend({})
    
    local KEYWORDS = {
    	["local"]=true, ["function"]=true, ["end"]=true, ["if"]=true, ["then"]=true,
    	["else"]=true, ["elseif"]=true, ["for"]=true, ["in"]=true, ["do"]=true,
    	["while"]=true, ["repeat"]=true, ["until"]=true, ["return"]=true, ["and"]=true,
    	["or"]=true, ["not"]=true, ["nil"]=true, ["true"]=true, ["false"]=true,
    }
    
    local function escapeXml(s)
    	s = s:gsub("&", "&amp;")
    	s = s:gsub("<", "&lt;")
    	s = s:gsub(">", "&gt;")
    	return s
    end
    
    local function rgbhex(c)
    	return string.format("#%02X%02X%02X", math.floor(c.R*255+0.5), math.floor(c.G*255+0.5), math.floor(c.B*255+0.5))
    end
    
    local function highlightLua(text, theme)
    	-- Very simple highlighter: strings, comments, numbers, keywords
    	local t = theme.colors
    	local colStr = rgbhex(t.accent)
    	local colCom = rgbhex(t.textMuted)
    	local colNum = rgbhex(t.warning)
    	local colKey = rgbhex(t.primary)
    
    	local out = {}
    	for line in (text.."\n"):gmatch("(.-)\n") do
    		local s = escapeXml(line)
    		-- comments -- ...
    		local comment = s:match("%-%-.*$")
    		if comment then
    			s = s:gsub("%-%-.*$", function(c)
    				return string.format("<font color=\"%s\">%s</font>", colCom, escapeXml(c))
    			end)
    		end
    		-- strings (simple): '...' or "..."
    		s = s:gsub("'(.-)'", function(str)
    			return string.format("<font color=\"%s\">'%s'</font>", colStr, escapeXml(str))
    		end)
    		s = s:gsub('"(.-)"', function(str)
    			return string.format("<font color=\"%s\">\"%s\"</font>", colStr, escapeXml(str))
    		end)
    		-- numbers
    		s = s:gsub("(%f[%w_][0-9]+%f[^%w_])", function(num)
    			return string.format("<font color=\"%s\">%s</font>", colNum, num)
    		end)
    		-- keywords
    		s = s:gsub("(%f[%a_][%a_]+%f[^%a_])", function(word)
    			if KEYWORDS[word] then
    				return string.format("<font color=\"%s\">%s</font>", colKey, word)
    			end
    			return word
    		end)
    		out[#out+1] = s
    	end
    	return table.concat(out, "\n")
    end
    
    function CodeEditor.new(props)
    	props = props or {}
    	local self = setmetatable({}, CodeEditor)
    	self.Text = tostring(props.Text or "")
    	self.AutoSaveKey = props.AutoSaveKey
    	self.OnChanged = props.OnChanged
    	self.OnValidate = props.OnValidate or Validator.basicSyntax
    
    	-- Load autosave
    	if self.AutoSaveKey then
    		local saved = Storage.load(self.AutoSaveKey)
    		if type(saved) == "table" and type(saved.text) == "string" then
    			self.Text = saved.text
    		end
    	end
    
    	local theme = Theme.current()
    
    	local root = Util.Create("Frame", {
    		Name = "MintCodeEditor",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = props.Size or UDim2.fromOffset(520, 260),
    		ClipsDescendants = true,
    	})
    	self:_own(root)
    	Util.Roundify(root, 8, theme.colors.border, 0.9)
    
    	-- Top bar (validation state)
    	local status = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, -8, 0, 16),
    		Position = UDim2.fromOffset(4, 4),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		Text = "",
    		TextColor3 = theme.colors.textMuted,
    		Font = Enum.Font.Gotham,
    		TextSize = 12,
    	})
    	status.Parent = root
    
    	local editorArea = Util.Create("Frame", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, -8, 1, -28),
    		Position = UDim2.fromOffset(4, 20),
    	})
    	editorArea.Parent = root
    
    	-- Line numbers scroll view
    	local gutter = Util.Create("ScrollingFrame", {
    		BackgroundTransparency = 1,
    		BorderSizePixel = 0,
    		ScrollBarThickness = 0,
    		Size = UDim2.new(0, 36, 1, 0),
    		CanvasSize = UDim2.new(0,0,0,0),
    	})
    	gutter.Parent = editorArea
    	local gutterText = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Size = UDim2.new(1, 0, 0, 0),
    		TextXAlignment = Enum.TextXAlignment.Right,
    		TextYAlignment = Enum.TextYAlignment.Top,
    		Text = "",
    		TextColor3 = theme.colors.textMuted,
    		Font = Enum.Font.Code,
    		TextSize = 14,
    	})
    	gutterText.Parent = gutter
    
    	-- Main editor viewport
    	local viewport = Util.Create("ScrollingFrame", {
    		BackgroundTransparency = 1,
    		BorderSizePixel = 0,
    		ScrollBarThickness = 6,
    		Size = UDim2.new(1, -36, 1, 0),
    		Position = UDim2.new(0, 36, 0, 0),
    		CanvasSize = UDim2.new(0,0,0,0),
    		ScrollBarImageTransparency = 0.5,
    	})
    	viewport.Parent = editorArea
    
    	local highlight = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		RichText = true,
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Top,
    		Font = Enum.Font.Code,
    		TextSize = 14,
    		Text = "",
    		AutomaticSize = Enum.AutomaticSize.XY,
    		Size = UDim2.new(1, -6, 0, 0),
    	})
    	highlight.Parent = viewport
    
    	local input = Util.Create("TextBox", {
    		BackgroundTransparency = 1,
    		ClearTextOnFocus = false,
    		MultiLine = true,
    		TextEditable = true,
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Top,
    		Font = Enum.Font.Code,
    		TextSize = 14,
    		Text = self.Text,
    		CursorPosition = #self.Text + 1,
    		AutomaticSize = Enum.AutomaticSize.XY,
    		Size = UDim2.new(1, -6, 0, 0),
    	})
    	input.Parent = viewport
    
    	-- Ensure TextBox is on top for input
    	input.ZIndex = 2
    	highlight.ZIndex = 1
    
    	local function updateLineNumbers(lines)
    		local buff = {}
    		for i = 1, lines do buff[i] = tostring(i) end
    		gutterText.Text = table.concat(buff, "\n")
    		gutterText.Size = UDim2.new(1, 0, 0, gutterText.TextBounds.Y)
    		gutter.CanvasSize = UDim2.new(0,0,0, gutterText.TextBounds.Y + 8)
    	end
    
    	local function refresh()
    		-- Highlight
    		highlight.Text = highlightLua(self.Text, Theme.current())
    		-- Resize based on bounds
    		input.Text = self.Text
    		input.Size = UDim2.new(1, -6, 0, input.TextBounds.Y)
    		highlight.Size = UDim2.new(1, -6, 0, input.TextBounds.Y)
    		viewport.CanvasSize = UDim2.new(0,0,0, input.TextBounds.Y + 8)
    		-- Line numbers
    		local _, lines = self.Text:gsub("\n", "")
    		updateLineNumbers(lines + 1)
    		-- Validate
    		local ok, err = self.OnValidate(self.Text)
    		if ok then
    			status.Text = "Valid"
    			status.TextColor3 = Theme.current().colors.success
    		else
    			status.Text = string.format("Error: line %d col %d - %s", err.line or 0, err.col or 0, err.msg or "")
    			status.TextColor3 = Theme.current().colors.error
    		end
    	end
    
    	-- Sync scroll of gutter with viewport
    	self:_trackConn(viewport:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
    		gutter.CanvasPosition = Vector2.new(0, viewport.CanvasPosition.Y)
    	end))
    
    	-- Change handler
    	self:_trackConn(input:GetPropertyChangedSignal("Text"):Connect(function()
    		self.Text = input.Text
    		refresh()
    		if self.OnChanged then
    			local ok, err = pcall(self.OnChanged, self.Text)
    			if not ok then warn(err) end
    		end
    		if self.AutoSaveKey then
    			Storage.save(self.AutoSaveKey, { text = self.Text })
    		end
    	end))
    
    	-- Initial populate
    	refresh()
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		local s = root:FindFirstChildOfClass("UIStroke"); if s then s.Color = newTheme.colors.border end
    		status.TextColor3 = newTheme.colors.textMuted
    		refresh()
    	end))
    
    	self.Instance = root
    	self.Viewport = viewport
    	self.Input = input
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    function CodeEditor:SetText(t)
    	self.Text = tostring(t or "")
    	if self.Input then self.Input.Text = self.Text end
    end
    
    return CodeEditor
    
  end
  __modules["core/ErrorHandler"] = function(require, script)
    -- ErrorHandler: centralized user feedback and logging with levels
    local Event = require(script.Parent.Event)
    
    local ErrorHandler = {}
    
    ErrorHandler.event = Event.new() -- fires (level, message)
    
    local validLevels = {
    	info = true,
    	success = true,
    	warning = true,
    	error = true,
    }
    
    local function log(level, msg)
    	local prefix = string.upper(level)
    	if level == "error" then
    		warn("[Mint][" .. prefix .. "] " .. tostring(msg))
    	else
    		print("[Mint][" .. prefix .. "] " .. tostring(msg))
    	end
    end
    
    function ErrorHandler.notify(level, message)
    	level = string.lower(level or "info")
    	if not validLevels[level] then level = "info" end
    	log(level, message)
    	ErrorHandler.event:Fire(level, message)
    end
    
    -- Helper wrappers
    function ErrorHandler.info(msg) ErrorHandler.notify("info", msg) end
    function ErrorHandler.success(msg) ErrorHandler.notify("success", msg) end
    function ErrorHandler.warn(msg) ErrorHandler.notify("warning", msg) end
    function ErrorHandler.error(msg) ErrorHandler.notify("error", msg) end
    
    return ErrorHandler
    
  end
  __modules["core/Event"] = function(require, script)
    -- Simple Signal/Event utility
    local Event = {}
    Event.__index = Event
    
    function Event.new()
    	local self = setmetatable({}, Event)
    	self._bindable = Instance.new("BindableEvent")
    	self._connections = {}
    	return self
    end
    
    function Event:Connect(fn)
    	local conn = self._bindable.Event:Connect(fn)
    	table.insert(self._connections, conn)
    	return conn
    end
    
    function Event:Once(fn)
    	local connection
    	connection = self:Connect(function(...)
    		if connection.Connected then connection:Disconnect() end
    		fn(...)
    	end)
    	return connection
    end
    
    function Event:Fire(...)
    	self._bindable:Fire(...)
    end
    
    function Event:Destroy()
    	for _, c in ipairs(self._connections) do
    		if c.Connected then c:Disconnect() end
    	end
    	self._connections = {}
    	self._bindable:Destroy()
    end
    
    return Event
    
  end
  __modules["components/Notification"] = function(require, script)
    -- Notification (Toast) Manager
    -- Attaches to a ScreenGui and listens to ErrorHandler to show animated toasts
    -- API:
    -- local Notification = require(...components.Notification)
    -- Notification.Attach(screenGui, opts?)
    -- Notification.Notify(level, message, opts?)
    -- Notification.Detach()
    --
    -- opts: { Duration: number (default 3), MaxToasts: number (default 4), Position: "TopRight"|"BottomRight"|"TopLeft"|"BottomLeft" }
    
    local Util = require(script.Parent.Parent.core.Util)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local ErrorHandler = require(script.Parent.Parent.core.ErrorHandler)
    
    local Notification = {}
    
    local state = {
    	attachedGui = nil,
    	container = nil,
    	conns = {},
    	settings = {
    		Duration = 3,
    		MaxToasts = 4,
    		Position = "TopRight",
    	},
    }
    
    local function cornerAnchor(position)
    	if position == "TopRight" then
    		return Vector2.new(1,0), UDim2.new(1, -12, 0, 12)
    	elseif position == "BottomRight" then
    		return Vector2.new(1,1), UDim2.new(1, -12, 1, -12)
    	elseif position == "TopLeft" then
    		return Vector2.new(0,0), UDim2.new(0, 12, 0, 12)
    	else
    		return Vector2.new(0,1), UDim2.new(0, 12, 1, -12)
    	end
    end
    
    local function colorFor(level, theme)
    	local t = theme.colors
    	if level == "success" then return t.success end
    	if level == "warning" then return t.warning end
    	if level == "error" then return t.error end
    	return t.primary -- info/default
    end
    
    local function rebuildLayout()
    	local c = state.container
    	if not c then return end
    	for i, toast in ipairs(c:GetChildren()) do
    		if toast:IsA("Frame") then
    			toast.LayoutOrder = i
    		end
    	end
    end
    
    local function mountContainer(screenGui)
    	local theme = Theme.current()
    	local anchorPoint, position = cornerAnchor(state.settings.Position)
    	local container = Util.Create("Frame", {
    		Name = "Mint_ToastContainer",
    		BackgroundTransparency = 1,
    		BorderSizePixel = 0,
    		AnchorPoint = anchorPoint,
    		Position = position,
    		Size = UDim2.fromOffset(320, 10),
    		ZIndex = 1000,
    	})
    	container.Parent = screenGui
    
    	local list = Util.VList(container, 8, Enum.HorizontalAlignment.Right)
    	list.FillDirection = (anchorPoint.Y == 1) and Enum.FillDirection.Vertical or Enum.FillDirection.Vertical
    	list.SortOrder = Enum.SortOrder.LayoutOrder
    
    	state.container = container
    end
    
    local function ensureSpaceLimit()
    	if not state.container then return end
    	local frames = {}
    	for _, child in ipairs(state.container:GetChildren()) do
    		if child:IsA("Frame") then
    			frames[#frames+1] = child
    		end
    	end
    	if #frames > state.settings.MaxToasts then
    		-- remove the oldest (first)
    		local oldest = frames[1]
    		oldest:Destroy()
    		rebuildLayout()
    	end
    end
    
    local function createToast(level, message, opts)
    	opts = opts or {}
    	local theme = Theme.current()
    	local color = colorFor(level, theme)
    	local bg = theme.colors.surface
    	local txt = theme.colors.text
    
    	local toast = Util.Create("Frame", {
    		Name = "Toast",
    		BackgroundColor3 = bg,
    		BorderSizePixel = 0,
    		Size = UDim2.new(0, 320, 0, 44),
    		ClipsDescendants = true,
    		ZIndex = 1001,
    	})
    	Util.Roundify(toast, 8, theme.colors.border, 0.9)
    	Util.Padding(toast, 8)
    
    	-- Accent bar
    	local accent = Util.Create("Frame", {
    		BackgroundColor3 = color,
    		BorderSizePixel = 0,
    		Size = UDim2.new(0, 4, 1, 0),
    	})
    	accent.Parent = toast
    
    	local label = Util.Create("TextLabel", {
    		BackgroundTransparency = 1,
    		Position = UDim2.new(0, 10, 0, 0),
    		Size = UDim2.new(1, -20, 1, 0),
    		TextXAlignment = Enum.TextXAlignment.Left,
    		TextYAlignment = Enum.TextYAlignment.Center,
    		TextWrapped = true,
    		Text = tostring(message),
    		TextColor3 = txt,
    		Font = Enum.Font.Gotham,
    		TextSize = 14,
    	})
    	label.Parent = toast
    
    	toast.Parent = state.container
    	rebuildLayout()
    	ensureSpaceLimit()
    
    	-- Animate in from side
    	toast.AnchorPoint = Vector2.new(1,0)
    	toast.Position = UDim2.new(1, 340, 0, 0)
    	Animator.tween(toast, Animator.Durations.Normal, { Position = UDim2.new(1, 0, 0, 0) })
    
    	-- Auto-remove after duration
    	local duration = opts.Duration or state.settings.Duration
    	task.delay(duration, function()
    		if toast and toast.Parent then
    			Animator.tween(toast, Animator.Durations.Fast, { Position = UDim2.new(1, 340, 0, 0), BackgroundTransparency = 1 })
    			task.delay(Animator.Durations.Fast + 0.05, function()
    				if toast then toast:Destroy() end
    				rebuildLayout()
    			end)
    		end
    	end)
    
    	-- Click to dismiss
    	local button = Instance.new("TextButton")
    	button.Name = "HitArea"
    	button.BackgroundTransparency = 1
    	button.Text = ""
    	button.Size = UDim2.fromScale(1,1)
    	button.Parent = toast
    	button.MouseButton1Click:Connect(function()
    		if toast then toast:Destroy() end
    		rebuildLayout()
    	end)
    
    	-- Theme changes
    	Theme.changed:Connect(function(newTheme)
    		local c = colorFor(level, newTheme)
    		accent.BackgroundColor3 = c
    		toast.BackgroundColor3 = newTheme.colors.surface
    		label.TextColor3 = newTheme.colors.text
    		local s = toast:FindFirstChildOfClass("UIStroke"); if s then s.Color = newTheme.colors.border end
    	end)
    end
    
    function Notification.Attach(screenGui, opts)
    	if state.attachedGui == screenGui then return end
    	Notification.Detach()
    	state.attachedGui = screenGui
    	state.settings = setmetatable(opts or {}, { __index = state.settings })
    	mountContainer(screenGui)
    	-- Listen to ErrorHandler
    	state.conns[#state.conns+1] = ErrorHandler.event:Connect(function(level, msg)
    		Notification.Notify(level, msg)
    	end)
    end
    
    function Notification.Detach()
    	for _, c in ipairs(state.conns) do if c.Connected then c:Disconnect() end end
    	state.conns = {}
    	if state.container then state.container:Destroy() end
    	state.container = nil
    	state.attachedGui = nil
    end
    
    function Notification.Notify(level, message, opts)
    	if not state.container then return end
    	createToast(level or "info", message or "", opts)
    end
    
    return Notification
    
  end
  __modules["components/FileBrowser"] = function(require, script)
    -- FileBrowser/ScriptManager component: simple tree/list with selection and actions
    -- Props:
    -- Items: array of nodes { id=string, name=string, isFolder=bool, children=array }
    -- OnSelect(node)
    -- OnOpen(node)
    -- OnAction(actionName, node) optional; or set Action map on items for Registry use
    -- Size (UDim2) default (260, 300)
    -- Parent (Instance)
    
    local Util = require(script.Parent.Parent.core.Util)
    local Theme = require(script.Parent.Parent.core.ThemeManager)
    local Animator = require(script.Parent.Parent.core.Animator)
    local Base = require(script.Parent.Parent.core.ComponentBase)
    
    local FileBrowser = Base.extend({})
    
    local function flatten(nodes, depth, out)
    	out = out or {}
    	depth = depth or 0
    	for _, n in ipairs(nodes or {}) do
    		out[#out+1] = { node = n, depth = depth }
    		if n._expanded and n.children then
    			flatten(n.children, depth+1, out)
    		end
    	end
    	return out
    end
    
    function FileBrowser.new(props)
    	props = props or {}
    	local self = Base.init({})
    	setmetatable(self, FileBrowser)
    	self.Items = props.Items or {}
    	self.OnSelect = props.OnSelect
    	self.OnOpen = props.OnOpen
    	self.OnAction = props.OnAction
    	self._selectedId = nil
    
    	local theme = Theme.current()
    
    	local root = Util.Create("Frame", {
    		Name = "MintFileBrowser",
    		BackgroundColor3 = theme.colors.surface,
    		BorderSizePixel = 0,
    		Size = props.Size or UDim2.fromOffset(260, 300),
    	})
    	self:_own(root)
    	Util.Roundify(root, 8, theme.colors.border, 0.9)
    	Util.Padding(root, 6)
    
    	local list = Util.Create("ScrollingFrame", {
    		BackgroundTransparency = 1,
    		BorderSizePixel = 0,
    		ScrollBarThickness = 6,
    		CanvasSize = UDim2.new(0,0,0,0),
    		Size = UDim2.new(1, 0, 1, 0),
    	})
    	list.Parent = root
    	local uiList = Util.VList(list, 2, Enum.HorizontalAlignment.Left)
    	self:_trackConn(uiList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    		list.CanvasSize = UDim2.new(0,0,0, uiList.AbsoluteContentSize.Y + 8)
    	end))
    
    	local rows = {}
    
    	local function render()
    		list:ClearAllChildren()
    		rows = {}
    		local flat = flatten(self.Items)
    		for _, rec in ipairs(flat) do
    			local n = rec.node
    			local depth = rec.depth
    			local row = Util.Create("TextButton", {
    				AutoButtonColor = false,
    				BackgroundColor3 = theme.colors.inputBg,
    				BorderSizePixel = 0,
    				Size = UDim2.new(1, -6, 0, 24),
    				TextXAlignment = Enum.TextXAlignment.Left,
    				Text = "",
    			})
    			Util.Roundify(row, 6, theme.colors.border, 1)
    			row.Parent = list
    
    			local label = Util.Create("TextLabel", {
    				BackgroundTransparency = 1,
    				Position = UDim2.new(0, 8 + depth*16, 0, 0),
    				Size = UDim2.new(1, -8 - depth*16, 1, 0),
    				TextXAlignment = Enum.TextXAlignment.Left,
    				TextYAlignment = Enum.TextYAlignment.Center,
    				Text = (n.isFolder and "📁 " or "📄 ") .. tostring(n.name or n.id or "node"),
    				TextColor3 = theme.colors.text,
    				Font = Enum.Font.Gotham,
    				TextSize = 14,
    			})
    			label.Parent = row
    
    			-- Expand/collapse arrow for folders
    			if n.isFolder then
    				local arrow = Util.Create("TextButton", {
    					AutoButtonColor = false,
    					BackgroundTransparency = 1,
    					Text = n._expanded and "▼" or "▶",
    					TextColor3 = theme.colors.textMuted,
    					Font = Enum.Font.GothamBold,
    					TextSize = 12,
    					Size = UDim2.fromOffset(16, 16),
    					Position = UDim2.new(0, depth*16, 0.5, -8),
    				})
    				arrow.Parent = row
    				self:_trackConn(arrow.MouseButton1Click:Connect(function()
    					n._expanded = not n._expanded
    					render()
    				end))
    			end
    
    			self:_trackConn(row.MouseEnter:Connect(function()
    				Animator.tween(row, Animator.Durations.Fast, { BackgroundColor3 = theme.colors.inputBg:lerp(theme.colors.surface, 0.2) })
    			end))
    			self:_trackConn(row.MouseLeave:Connect(function()
    				Animator.tween(row, Animator.Durations.Fast, { BackgroundColor3 = theme.colors.inputBg })
    			end))
    
    			self:_trackConn(row.MouseButton1Click:Connect(function()
    				self._selectedId = n.id or n.name
    				if self.OnSelect then pcall(self.OnSelect, n) end
    				if not n.isFolder and self.OnOpen then pcall(self.OnOpen, n) end
    			end))
    
    			rows[#rows+1] = row
    		end
    	end
    
    	render()
    
    	self:_trackConn(Theme.changed:Connect(function(newTheme)
    		root.BackgroundColor3 = newTheme.colors.surface
    		render()
    	end))
    
    	self.Instance = root
    	if props.Parent then root.Parent = props.Parent end
    	return self
    end
    
    return FileBrowser
    
  end
  local function __require(target)
    local name
    if type(target) == "string" then
      name = target
    elseif type(target) == "table" then
      name = target.__moduleName
      if not name then error("Invalid require target; missing __moduleName") end
    else
      error("require expects string or script-like table")
    end
    if __cache[name] ~= nil then return __cache[name] end
    local fn = __modules[name]
    if not fn then error("Module not found: " .. tostring(name)) end
    local script = __scriptIndex[name] or __root
    local result = fn(__require, script)
    __cache[name] = result
    return result
  end
  local Mint = __require("init")
  return Mint
end
