-- MinT UI Library bundler
-- Requires Lua + LuaFileSystem (lfs). Run from the repo root:
--   lua tools/build_mint.lua
-- Produces Mint.min.lua which returns a function; calling it returns the Mint table.

local lfs = require('lfs')

local SRC_DIR = 'src'
local OUT_FILE = 'Mint.min.lua'

-- Utility
local function read_file(path)
  local f, err = io.open(path, 'rb')
  assert(f, 'Failed to open ' .. path .. ': ' .. tostring(err))
  local s = f:read('*a')
  f:close()
  return s
end

local function write_file(path, content)
  local f, err = io.open(path, 'wb')
  assert(f, 'Failed to write ' .. path .. ': ' .. tostring(err))
  f:write(content)
  f:close()
end

local function norm(path)
  path = path:gsub('\\', '/')
  -- remove leading ./
  path = path:gsub('^%./', '')
  return path
end

-- Collect Lua modules
local modules = {} -- key -> { path=fsPath, rel=relKey, source=string }

local function scan(dir)
  for entry in lfs.dir(dir) do
    if entry ~= '.' and entry ~= '..' then
      local full = dir .. '/' .. entry
      local attr = lfs.attributes(full)
      if attr.mode == 'directory' then
        scan(full)
      else
        if entry:match('%.lua$') then
          local rel = norm(full):gsub('^' .. norm(SRC_DIR) .. '/?', '')
          local key = rel:gsub('%.lua$', '') -- e.g. core/Util, components/Button, init
          modules[key] = {
            path = full,
            rel = key,
            source = read_file(full),
          }
        end
      end
    end
  end
end

scan(SRC_DIR)
assert(modules['init'], 'src/init.lua not found')

-- Build a tree of nodes to emulate script.Parent traversal
local function newNode(name, isModule, moduleName)
  return { name = name, children = {}, parent = nil, isModule = isModule or false, moduleName = moduleName }
end

-- Root is the init module node
local root = newNode('Mint', true, 'init')

-- Ensure top-level folders exist under root for each module path
for key, mod in pairs(modules) do
  if key ~= 'init' then
    local segs = {}
    for s in key:gmatch('[^/]+') do table.insert(segs, s) end
    local parent = root
    for i = 1, #segs do
      local seg = segs[i]
      local isLast = (i == #segs)
      local name = seg
      if isLast then
        -- module node (strip .lua already)
        local mnode = newNode(name, true, key)
        mnode.parent = parent
        parent.children[name] = mnode
      else
        -- folder node
        local child = parent.children[name]
        if not child then
          child = newNode(name, false, nil)
          child.parent = parent
          parent.children[name] = child
        end
        parent = child
      end
    end
  end
end

-- Also attach top-level folders under root for convenience when resolving from init
for key, mod in pairs(modules) do
  if key ~= 'init' then
    local top = key:match('^([^/]+)/')
    if top and not root.children[top] then
      local child = newNode(top, false, nil)
      child.parent = root
      root.children[top] = child
    end
  end
end

-- Build a mapping from moduleName -> node for quick lookup
local moduleNodeMap = {}
local function traverse(node)
  if node.isModule and node.moduleName then
    moduleNodeMap[node.moduleName] = node
  end
  for _, c in pairs(node.children) do
    traverse(c)
  end
end
traverse(root)

-- Generate Lua bundle
local out = {}

local function emit(line) table.insert(out, line .. '\n') end

emit('-- Auto-generated by tools/build_mint.lua')
emit('return function()')
emit('  local __modules = {}')
emit('  local __cache = {}')
emit('  local function __mkNode(name, parent)')
emit('    local t = { Name = name, Parent = parent, children = {} }')
emit('    return t')
emit('  end')
emit('  local __scriptIndex = {}')

-- Emit script tree construction
local counter = 0
local nodeVarMap = {}

local function declareNodeVar(parentVar, name)
  counter = counter + 1
  local var = '__n' .. counter
  emit(string.format('  local %s = __mkNode(%q, %s)', var, name, parentVar or 'nil'))
  if parentVar then
    emit(string.format('  %s[%q] = %s', parentVar, name, var))
  end
  return var
end

-- Recursively emit nodes
local function emitTree(node, parentVar)
  local var = declareNodeVar(parentVar, node.name)
  if node.isModule and node.moduleName then
    emit(string.format('  %s.__moduleName = %q', var, node.moduleName))
    emit(string.format('  __scriptIndex[%q] = %s', node.moduleName, var))
  end
  for name, child in pairs(node.children) do
    emitTree(child, var)
  end
  return var
end

local rootVar = emitTree(root, nil)
emit(string.format('  local __root = %s', rootVar))

-- Emit module functions
for key, mod in pairs(modules) do
  local src = mod.source
  -- Normalize line endings
  src = src:gsub('\r\n', '\n')
  emit(string.format('  __modules[%q] = function(require, script)', key))
  -- Indent source by two spaces for cleanliness
  for line in src:gmatch('([\0-\255]-)\n') do
    emit('    ' .. line)
  end
  -- Ensure last line
  if not src:match('\n$') then
    emit('    ' .. src)
  end
  emit('  end')
end

-- Emit require shim
emit('  local function __require(target)')
emit('    local name')
emit('    if type(target) == "string" then')
emit('      name = target')
emit('    elseif type(target) == "table" then')
emit('      name = target.__moduleName')
emit('      if not name then error("Invalid require target; missing __moduleName") end')
emit('    else')
emit('      error("require expects string or script-like table")')
emit('    end')
emit('    if __cache[name] ~= nil then return __cache[name] end')
emit('    local fn = __modules[name]')
emit('    if not fn then error("Module not found: " .. tostring(name)) end')
emit('    local script = __scriptIndex[name] or __root')
emit('    local result = fn(__require, script)')
emit('    __cache[name] = result')
emit('    return result')
emit('  end')

-- Return the Mint table (init)
emit('  local Mint = __require("init")')
emit('  return Mint')
emit('end')

write_file(OUT_FILE, table.concat(out))

print('Bundled ' .. tostring((function() local n=0 for _ in pairs(modules) do n=n+1 end return n end)()) .. ' modules into ' .. OUT_FILE)

